(function () {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function () {
      return exports;
    };
    var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      defineProperty = Object.defineProperty || function (obj, key, desc) {
        obj[key] = desc.value;
      },
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg,
            value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }
        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method,
        method = delegate.iterator[methodName];
      if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1,
            next = function next() {
              for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              return next.value = undefined, next.done = !0, next;
            };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (val) {
      var object = Object(val),
        keys = [];
      for (var key in object) keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
            record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  var addClass = function addClass() {
    var $class = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var $elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if ($class && $elements.length) {
      for (var i = 0; i < $elements.length; i++) {
        if ($elements[i]) {
          $elements[i].classList.add($class);
        }
      }
    }
  };
  var addClassesToElements = function addClassesToElements() {
    var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (classes.length && elements.length) {
      elements.forEach(function (element) {
        var _element$classList;
        (_element$classList = element.classList).add.apply(_element$classList, _toConsumableArray(classes));
      });
    }
  };
  var debounce = function debounce(func, delay) {
    var inDebounce;
    return function () {
      var context = this;
      var args = arguments;
      clearTimeout(inDebounce);
      inDebounce = setTimeout(function () {
        return func.apply(context, args);
      }, delay);
    };
  };
  var filterObjectFromArrayByID = function filterObjectFromArrayByID() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    for (var i = 0; i < arr.length; i++) {
      if (arr[i].id === id) {
        return arr[i];
      }
    }
    return false;
  };
  var getArrayOfElementsByTag = function getArrayOfElementsByTag() {
    var $elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['body', 'footer', 'header', 'main'];
    var filteredElements = $elements.filter(function (tag) {
      return document.getElementsByTagName(tag)[0];
    }) || [];
    return filteredElements.map(function (tag) {
      return document.getElementsByTagName(tag)[0];
    }) || [];
  };
  var getElementHeightByTag = function getElementHeightByTag() {
    var $tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return document.getElementsByTagName($tag)[0].offsetHeight || 0;
  };
  var getLocalStorageValueByKey = function getLocalStorageValueByKey($key) {
    return localStorage.getItem($key);
  };
  var getTimeStamp = function getTimeStamp() {
    var d = new Date();
    return d.getTime();
  };
  var removeClass = function removeClass() {
    var $class = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var $elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if ($class && $elements.length) {
      for (var i = 0; i < $elements.length; i++) {
        if ($elements[i]) {
          $elements[i].classList.remove($class);
        }
      }
    }
  };
  var removeClassesFromElements = function removeClassesFromElements() {
    var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (classes.length && elements.length) {
      elements.forEach(function (element) {
        var _element$classList2;
        (_element$classList2 = element.classList).remove.apply(_element$classList2, _toConsumableArray(classes));
      });
    }
  };
  var setCSSVariable = function setCSSVariable() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (id && value) document.documentElement.style.setProperty("--".concat(id), value);
  };
  var setElementsHeightToCSSVariable = function setElementsHeightToCSSVariable() {
    var elements = [{
      var_id: 'theme-header-height--total',
      element_id: 'shopify-section-header'
    }, {
      var_id: 'theme-announcement-height--total',
      element_id: 'shopify-section-announcements'
    }];
    elements.forEach(function (item) {
      var var_id = item.var_id,
        element_id = item.element_id;
      var value = document.getElementById(element_id) ? document.getElementById(element_id).offsetHeight : 0;
      document.documentElement.style.setProperty("--".concat(var_id), "".concat(value, "px"));
    });
  };
  var setLocalStorage = function setLocalStorage($key, $value) {
    localStorage.setItem($key, $value);
  };
  var throttle$1 = function throttle(func, limit) {
    var lastFunc;
    var lastRan;
    return function () {
      var context = this;
      var args = arguments;
      if (!lastRan) {
        func.apply(context, args);
        lastRan = Date.now();
      } else {
        clearTimeout(lastFunc);
        lastFunc = setTimeout(function () {
          if (Date.now() - lastRan >= limit) {
            func.apply(context, args);
            lastRan = Date.now();
          }
        }, limit - (Date.now() - lastRan));
      }
    };
  };
  var toggleClass = function toggleClass() {
    var $class = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var $elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if ($class && $elements.length) {
      for (var i = 0; i < $elements.length; i++) {
        if ($elements[i]) {
          $elements[i].classList.toggle($class);
        }
      }
    }
  };
  var Tools = {
    addClass: addClass,
    addClassesToElements: addClassesToElements,
    debounce: debounce,
    filterObjectFromArrayByID: filterObjectFromArrayByID,
    getArrayOfElementsByTag: getArrayOfElementsByTag,
    getElementHeightByTag: getElementHeightByTag,
    getLocalStorageValueByKey: getLocalStorageValueByKey,
    getTimeStamp: getTimeStamp,
    removeClass: removeClass,
    removeClassesFromElements: removeClassesFromElements,
    setCSSVariable: setCSSVariable,
    setElementsHeightToCSSVariable: setElementsHeightToCSSVariable,
    setLocalStorage: setLocalStorage,
    throttle: throttle$1,
    toggleClass: toggleClass
  };

  var set = function set() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var expires = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var d = new Date();
    d.setTime(d.getTime() + expires * 24 * 60 * 60 * 1000);
    expires = "expires=" + d.toUTCString();
    document.cookie = name + "=" + value + ";" + expires + ";path=/";
  };
  var get = function get() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    name = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) == ' ') {
        c = c.substring(1);
      }
      if (c.indexOf(name) == 0) {
        return c.substring(name.length, c.length);
      }
    }
    return '';
  };
  var Cookies = {
    get: get,
    set: set
  };

  var cookieName = 'vp_shopify_announcements';
  var hideAnnouncements = function hideAnnouncements() {
    (document.querySelectorAll('.header__announcements') || []).forEach(function (element) {
      element.classList.remove('show');
      Tools.setElementsHeightToCSSVariable();
      Cookies.set(cookieName, 'hide', 1);
    });
  };
  var showAnnouncements = function showAnnouncements() {
    (document.querySelectorAll('.header__announcements') || []).forEach(function (element) {
      element.classList.add('show');
      Tools.setElementsHeightToCSSVariable();
    });
  };
  var onClickHideAnnouncements = function onClickHideAnnouncements() {
    (document.querySelectorAll('.js-hide-announcements') || []).forEach(function (button) {
      button.addEventListener('click', function () {
        hideAnnouncements();
      });
    });
  };
  var init$6 = function init() {
    if (!Cookies.get(cookieName)) {
      showAnnouncements();
    }
    onClickHideAnnouncements();
  };
  var Announcements = {
    init: init$6
  };

  var format = function format() {
    var _Theme;
    var price = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return "$".concat((price / 100).toFixed(2), " ").concat(((_Theme = Theme) === null || _Theme === void 0 ? void 0 : _Theme.currency) || 'CAD');
  };
  var Money = {
    format: format
  };

  var cartLineItem = function cartLineItem() {
    var _Theme$svg$icon$trash, _Theme$svg$icon, _Theme$tools;
    var line_item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _line_item$block_name = line_item.block_name,
      block_name = _line_item$block_name === void 0 ? 'cart-line-item' : _line_item$block_name,
      featured_image = line_item.featured_image,
      final_line_price = line_item.final_line_price,
      key = line_item.key;
      line_item.price;
      var product_title = line_item.product_title;
      line_item.product_type;
      var quantity = line_item.quantity;
      line_item.title;
      var url = line_item.url;
      line_item.variant_id;
      var variant_title = line_item.variant_title;
    var icon_trash = (_Theme$svg$icon$trash = (_Theme$svg$icon = Theme.svg.icon) === null || _Theme$svg$icon === void 0 ? void 0 : _Theme$svg$icon.trash) !== null && _Theme$svg$icon$trash !== void 0 ? _Theme$svg$icon$trash : '';
    var image = {
      classes: 'lazyload lazyload-item lazyload-item--image lazypreload lazyload-item--inline inline',
      src: (_Theme$tools = Theme.tools) !== null && _Theme$tools !== void 0 && _Theme$tools.imgURLFilter ? Theme.tools.imgURLFilter(featured_image.url, 'small') : featured_image.url
    };
    var price_formatted = Money.format(final_line_price);
    return "\n    <div class=\"".concat(block_name, "\" id=\"").concat(block_name, "--").concat(key, "\" data-key=\"").concat(key, "\">\n      <div class=\"").concat(block_name, "__image\">\n        <a class=\"").concat(block_name, "__image-link link\" href=\"").concat(url, "\" title=\"").concat(product_title, "\" target=\"_self\">\n          <img class=\"").concat(image.classes, "\" src=\"").concat(image.src, "\" alt=\"").concat(featured_image.alt, "\" width=\"").concat(featured_image.width, "\" height=\"").concat(featured_image.height, "\" />\n        </a>\n      </div>\n      <div class=\"").concat(block_name, "__content text--uppercase\">\n        <div class=\"").concat(block_name, "__info\">\n          <strong class=\"").concat(block_name, "__product-title\">\n            <a class=\"").concat(block_name, "__product-title-link link\" href=\"").concat(url, "\" title=\"").concat(product_title, "\" target=\"_self\">").concat(product_title, "</a>\n          </strong>\n          ").concat(variant_title ? "<span class=\"".concat(block_name, "__variant-title\">").concat(variant_title, "</span>") : '', "\n        </div>\n        <div class=\"").concat(block_name, "__price\">").concat(price_formatted, "</div>\n        <div class=\"").concat(block_name, "__stepper\">").concat(stepper({
      quantity: quantity
    }), "</div>\n        <div class=\"").concat(block_name, "__action\">\n          <button class=\"").concat(block_name, "__button-remove button button--remove-cart-line-item js--remove-cart-line-item\" type=\"button\">\n            ").concat(icon_trash !== null && icon_trash !== void 0 ? icon_trash : 'Remove', "\n          </button>\n        </div>\n      </div>\n    </div>\n  ");
  };
  var cartNotificationError = function cartNotificationError() {
    var _Theme$icons$triangle, _Theme$icons;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _data$block_name = data.block_name,
      block_name = _data$block_name === void 0 ? 'cart-notification' : _data$block_name,
      description = data.description,
      _data$triangle = data.triangle,
      triangle = _data$triangle === void 0 ? (_Theme$icons$triangle = (_Theme$icons = Theme.icons) === null || _Theme$icons === void 0 ? void 0 : _Theme$icons.triangle) !== null && _Theme$icons$triangle !== void 0 ? _Theme$icons$triangle : '' : _data$triangle;
    return "\n    ".concat(triangle ? "<div class=\"".concat(block_name, "__triangle\">").concat(triangle, "</div>") : '', "\n    <div class=\"").concat(block_name, "__main\">\n      <span class=\"").concat(block_name, "__notice\">Oops!</span>\n      <strong class=\"").concat(block_name, "__heading heading--primary\">").concat(description, "</strong>\n    </div>\n  ");
  };
  var cartNotificationSuccess = function cartNotificationSuccess() {
    var _Theme$icons$triangle2, _Theme$icons2, _Theme$tools2;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _data$block_name2 = data.block_name,
      block_name = _data$block_name2 === void 0 ? 'cart-notification' : _data$block_name2,
      featured_image = data.featured_image,
      _data$options_with_va = data.options_with_values,
      options_with_values = _data$options_with_va === void 0 ? [] : _data$options_with_va,
      product_has_only_default_variant = data.product_has_only_default_variant,
      product_title = data.product_title;
      data.product_type;
      var _data$triangle2 = data.triangle,
      triangle = _data$triangle2 === void 0 ? (_Theme$icons$triangle2 = (_Theme$icons2 = Theme.icons) === null || _Theme$icons2 === void 0 ? void 0 : _Theme$icons2.triangle) !== null && _Theme$icons$triangle2 !== void 0 ? _Theme$icons$triangle2 : '' : _data$triangle2,
      url = data.url;
      data.variant_title;
    var image = {
      classes: 'lazyload lazyload-item lazyload-item--image lazypreload',
      src: (_Theme$tools2 = Theme.tools) !== null && _Theme$tools2 !== void 0 && _Theme$tools2.imgURLFilter ? Theme.tools.imgURLFilter(featured_image.url, 'medium') : featured_image.url
    };
    var options = options_with_values.map(function (option) {
      return "\n      <div class=\"".concat(block_name, "__option\">\n        <span class=\"").concat(block_name, "__option-name\">").concat(option.name, "</span>\n        <span class=\"").concat(block_name, "__option-value\">").concat(option.value, "</span>\n      </div>\n    ");
    }).join('');
    return "\n    ".concat(triangle ? "<div class=\"".concat(block_name, "__triangle\">").concat(triangle, "</div>") : '', "\n    <div class=\"").concat(block_name, "__main\">\n      <span class=\"").concat(block_name, "__notice\">1 Item Added to Cart!</span>\n        <div class=\"").concat(block_name, "__image\">\n          <a class=\"").concat(block_name, "__image-link link\" href=\"").concat(url, "\" title=\"").concat(product_title, "\" target=\"_self\">\n            <img class=\"").concat(image.classes, "\" src=\"").concat(image.src, "\" alt=\"").concat(featured_image.alt, "\" width=\"").concat(featured_image.width, "\" height=\"").concat(featured_image.height, "\" />\n          </a>\n        </div>\n      <strong class=\"").concat(block_name, "__heading heading--primary\">").concat(product_title, "</strong>\n      ").concat(!product_has_only_default_variant && options ? "<span class=\"".concat(block_name, "__options\">").concat(options, "</span>") : '', "\n      <div class=\"").concat(block_name, "__cta\">\n        <a class=\"").concat(block_name, "__cta-link link\" href=\"/checkout\" title=\"Checkout\" target=\"_self\" />Checkout</a>\n      </div>\n    </div>\n  ");
  };
  var stepper = function stepper() {
    var _Theme$svg$button$ste, _Theme$svg$button$ste2, _Theme$svg$button$ste3, _Theme$svg$button$ste4;
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _data$block_name3 = data.block_name,
      block_name = _data$block_name3 === void 0 ? 'stepper' : _data$block_name3,
      quantity = data.quantity;
    var button = {
      decrease: (_Theme$svg$button$ste = (_Theme$svg$button$ste2 = Theme.svg.button.stepper) === null || _Theme$svg$button$ste2 === void 0 ? void 0 : _Theme$svg$button$ste2.decrease) !== null && _Theme$svg$button$ste !== void 0 ? _Theme$svg$button$ste : '-',
      increase: (_Theme$svg$button$ste3 = (_Theme$svg$button$ste4 = Theme.svg.button.stepper) === null || _Theme$svg$button$ste4 === void 0 ? void 0 : _Theme$svg$button$ste4.increase) !== null && _Theme$svg$button$ste3 !== void 0 ? _Theme$svg$button$ste3 : '+'
    };
    return "\n    <div class=\"".concat(block_name, "\">\n      <button class=\"").concat(block_name, "__button button button--stepper button--svg decrease js--stepper-button\" type=\"button\">\n        <span class=\"").concat(block_name, "__button-icon button__icon\">").concat(button.decrease, "</span>\n      </button>\n      <input class=\"").concat(block_name, "__input input--secondary js--stepper-input\" type=\"number\" name=\"quantity\" min=\"1\" max=\"9999\" value=\"").concat(quantity, "\" readonly>\n      <button class=\"").concat(block_name, "__button button button--stepper button--svg increase js--stepper-button\" type=\"button\">\n        <span class=\"").concat(block_name, "__button-icon button__icon\">").concat(button.increase, "</span>\n      </button>\n    </div>\n  ");
  };
  var Templates = {
    cartLineItem: cartLineItem,
    cartNotificationError: cartNotificationError,
    cartNotificationSuccess: cartNotificationSuccess
  };

  var elements$5 = {
    cart: document.querySelectorAll('.js--cart') || []
  };
  var cartEmptyMessage = function cartEmptyMessage() {
    var _Theme$settings$cart_, _Theme$settings;
    var message = (_Theme$settings$cart_ = (_Theme$settings = Theme.settings) === null || _Theme$settings === void 0 ? void 0 : _Theme$settings.cart_empty_message) !== null && _Theme$settings$cart_ !== void 0 ? _Theme$settings$cart_ : '<p>Oops! Nothing added to your cart yet :(</p>';
    elements$5.cart.forEach(function (element) {
      element.innerHTML = "\n      <div class=\"cart-empty-message body-copy--primary body-copy--1\">".concat(message, "</div>\n    ");
    });
  };
  var cartLineItemErrorMessage = function cartLineItemErrorMessage() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Something went wrong!';
    var element = document.createElement("div");
    var parent = document.querySelector(".cart-line-item[data-key=\"".concat(key, "\"]")) || false;
    if (parent) {
      element.classList.add('cart-line-item__error-message');
      element.innerHTML = "<strong class=\"heading--primary heading--3\">".concat(message, "</strong>");
      parent.appendChild(element);
      anime.timeline({
        targets: element,
        complete: function complete(anim) {
          element.remove();
        }
      }).add({
        delay: 0,
        duration: 750,
        opacity: 1,
        translateX: [200, 0]
      }).add({
        delay: 3200,
        duration: 550,
        opacity: 0,
        translateX: [0, 200]
      }).play;
    }
  };
  var cartLineItemRemoveByKey = function cartLineItemRemoveByKey() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var element = document.getElementById("cart-line-item--".concat(key)) || false;
    if (element) {
      anime.timeline({
        targets: element,
        easing: 'easeOutElastic(1, .8)',
        complete: function complete(anim) {
          element.remove();
        }
      }).add({
        delay: 500,
        duration: 700,
        endDelay: 700,
        translateX: 250,
        opacity: 0
      }).play;
    }
  };
  var cartLineItemPrice = function cartLineItemPrice() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var line_items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    if (line_items.length) {
      var _loop = function _loop(i) {
        if (key === line_items[i].key) {
          (document.querySelectorAll("[data-key=\"".concat(key, "\"] .cart-line-item__price")) || []).forEach(function (element) {
            element.innerHTML = Money.format(line_items[i].final_line_price);
          });
        }
      };
      for (var i = 0; i < line_items.length; i++) {
        _loop(i);
      }
    }
  };
  var cartLineItemsQuantity = function cartLineItemsQuantity() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var quantity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var line_items = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    if (line_items.length) {
      var _loop2 = function _loop2(i) {
        if (key === line_items[i].key) {
          if (quantity > line_items[i].quantity) {
            // show message stating no inventory
            (document.querySelectorAll("[data-key=\"".concat(key, "\"] input[name=\"quantity\"]")) || []).forEach(function (element) {
              element.value = line_items[i].quantity;
            });
          }
          return "break";
        }
      };
      for (var i = 0; i < line_items.length; i++) {
        var _ret = _loop2(i);
        if (_ret === "break") break;
      }
    }
  };
  var cartLineItemsToElement = function cartLineItemsToElement() {
    var line_items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    elements.forEach(function (element) {
      var template = '';
      for (var i = 0; i < line_items.length; i++) {
        template += Templates.cartLineItem(line_items[i]);
      }
      element.innerHTML = template;
    });
  };
  var cartLineItemsCount = function cartLineItemsCount() {
    var line_items_total = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    (document.querySelectorAll('.js--cart-line-items-total') || []).forEach(function (element) {
      element.innerHTML = "".concat(line_items_total);
    });
  };
  var cartNotification = function cartNotification() {
    var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'success';
    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var block_name = 'cart-notification';
    var element = document.createElement('div');
    var parent = document.querySelector('main[role="main"]') || false;
    var animation_delay = 'error' == status ? 4000 : 3000;
    switch (status) {
      case 'error':
        {
          element.innerHTML = Templates.cartNotificationError(data);
          break;
        }
      default:
        {
          element.innerHTML = Templates.cartNotificationSuccess(data);
          break;
        }
    }
    element.classList.add(block_name, 'body-copy--primary');
    parent.appendChild(element);
    anime.timeline({
      targets: element,
      complete: function complete(anim) {
        setTimeout(function () {
          element.remove();
        }, 250);
      }
    }).add({
      delay: 0,
      duration: 1000,
      opacity: 1,
      translateY: [-20, 0]
    }).add({
      delay: animation_delay,
      duration: 550,
      opacity: 0,
      translateY: [0, -100]
    }).play;
  };
  var cartSubtotal = function cartSubtotal() {
    var subtotal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    (document.querySelectorAll('.js--cart-subtotal') || []).forEach(function (element) {
      element.innerHTML = Money.format(subtotal);
    });
  };
  var Render = {
    cartEmptyMessage: cartEmptyMessage,
    cartLineItemErrorMessage: cartLineItemErrorMessage,
    cartLineItemRemoveByKey: cartLineItemRemoveByKey,
    cartLineItemPrice: cartLineItemPrice,
    cartLineItemsQuantity: cartLineItemsQuantity,
    cartLineItemsToElement: cartLineItemsToElement,
    cartLineItemsCount: cartLineItemsCount,
    cartNotification: cartNotification,
    cartSubtotal: cartSubtotal
  };

  var elements$4 = {
    cart: document.querySelectorAll('form.js--cart') || [],
    cart_footer_note: document.querySelectorAll('.cart-footer__note') || []
  };
  var addToCart = function addToCart() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var quantity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    if (id) {
      fetch('/cart/add.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          items: [{
            id: id,
            quantity: quantity
          }]
        })
      }).then(function (response) {
        return response.json();
      }).then(function (data) {
        if (422 == data.status) {
          Render.cartNotification('error', data);
        } else {
          var _data$items;
          Render.cartNotification('success', (_data$items = data.items) === null || _data$items === void 0 ? void 0 : _data$items[0]);
          getCart().then(function (cart) {
            toggleCheckoutButtonUsability('enable');
            toggleCartNoteUsability('enable');
            Render.cartLineItemsCount(cart.item_count);
            //Render.cartLineItemsToElement( cart.items, elements.cart );
            Render.cartSubtotal(cart.items_subtotal_price);
          });
        }
      })["catch"](function (error) {
        console.log('[ addToCart() ] :: Error', error);
      });
    }
  };
  var emptyCart = function emptyCart() {
    fetch('/cart/clear.js', {
      method: 'POST'
    }).then(function (response) {
      return response.json();
    }).then(function (data) {})["catch"](function (error) {
      console.error('[ emptyCart() ] :: Error', error);
    });
  };
  var getCart = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch('/cart.js', {
              method: 'GET'
            }).then(function (response) {
              return response.json();
            });
          case 2:
            return _context.abrupt("return", _context.sent);
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function getCart() {
      return _ref.apply(this, arguments);
    };
  }();
  var onClickAddProductToCart = function onClickAddProductToCart() {
    (document.querySelectorAll('.js--add-to-cart, .js--add-to-cart-from-collection') || []).forEach(function (button) {
      button.addEventListener('click', function (event) {
        event.preventDefault();
        var quantity = 1;
        var variantID = 0;
        switch (button.type) {
          case 'button':
            {
              var _button$dataset;
              // from PLP button
              variantID = parseInt(((_button$dataset = button.dataset) === null || _button$dataset === void 0 ? void 0 : _button$dataset.productVariantId) || 0);
              break;
            }
          case 'submit':
            {
              // from PDP form
              var form = button.closest('form') || false;
              var inputQuantity = form.querySelector("input[name='quantity']");
              var inputOptions = form.querySelectorAll("input[name='id']");
              var inputOptionChecked = Array.from(inputOptions).find(function (radio) {
                return radio.checked;
              });
              quantity = parseInt(inputQuantity.value || 0);
              variantID = parseInt(inputOptionChecked.value || 0);
              break;
            }
        }
        addToCart(variantID, quantity);
      });
    });
  };
  var onClickRemoveCartLineItem = function onClickRemoveCartLineItem() {
    document.addEventListener('click', function (event) {
      if (event.target.closest('.js--remove-cart-line-item')) {
        var _button$closest;
        var button = event.target.closest('.js--remove-cart-line-item');
        var cart_line_item = (_button$closest = button.closest('.cart-line-item')) !== null && _button$closest !== void 0 ? _button$closest : false;
        var cart_line_item_key = cart_line_item.dataset.key || '';
        changeCartLineItemByKey(cart_line_item_key, 0);
      }
    });
  };
  var onClickUpdateStepper = function onClickUpdateStepper() {
    function changeCartLineItem(event) {
      if (event.target.closest('.js--stepper-button')) {
        var _event$target$closest, _event$target, _event$target$closest2, _event$target$closest3, _event$target$closest4, _event$target2, _event$target2$closes, _event$target2$closes2;
        var key = (_event$target$closest = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : (_event$target$closest2 = _event$target.closest('.cart-line-item')) === null || _event$target$closest2 === void 0 ? void 0 : (_event$target$closest3 = _event$target$closest2.dataset) === null || _event$target$closest3 === void 0 ? void 0 : _event$target$closest3.key) !== null && _event$target$closest !== void 0 ? _event$target$closest : '';
        var value = (_event$target$closest4 = (_event$target2 = event.target) === null || _event$target2 === void 0 ? void 0 : (_event$target2$closes = _event$target2.closest('.stepper')) === null || _event$target2$closes === void 0 ? void 0 : (_event$target2$closes2 = _event$target2$closes.querySelector('input[type="number"]')) === null || _event$target2$closes2 === void 0 ? void 0 : _event$target2$closes2.value) !== null && _event$target$closest4 !== void 0 ? _event$target$closest4 : '';
        changeCartLineItemByKey(key, value);
      }
    }
    document.addEventListener('click', function (event) {
      if (event.target.closest('.js--stepper-button')) {
        var button = event.target.closest('.js--stepper-button');
        var stepper = button.closest('.stepper') || false;
        var stepper_input = stepper.querySelector('input[type="number"]') || false;
        if (button && stepper_input) {
          var min = parseInt(stepper_input.min);
          var max = parseInt(stepper_input.max);
          var quantity = parseInt(stepper_input.value);
          if (button.classList.contains('increase')) {
            if (quantity < max) {
              quantity = ++quantity;
            }
          } else {
            if (quantity > min) {
              quantity = --quantity;
            }
          }
          updateStepperButtonStates(quantity, min, max, stepper);
          updateStepperValue(quantity, stepper);
        }
      }
    });
    document.addEventListener('click', Tools.debounce(changeCartLineItem, 500));
  };
  var toggleCheckoutButtonUsability = function toggleCheckoutButtonUsability() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'enable';
    (document.querySelectorAll('button[name="checkout"]') || []).forEach(function (button) {
      switch (state) {
        case 'enable':
          {
            button.disabled = false;
            break;
          }
        case 'disable':
          {
            button.disabled = true;
            break;
          }
      }
    });
  };
  var toggleCartNoteUsability = function toggleCartNoteUsability() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'enable';
    elements$4.cart_footer_note.forEach(function (element) {
      switch (state) {
        case 'enable':
          {
            element.classList.remove('d-none');
            break;
          }
        case 'disable':
          {
            element.classList.add('d-none');
            break;
          }
      }
    });
  };
  var changeCartLineItemByKey = function changeCartLineItemByKey() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var quantity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (key) {
      fetch('/cart/change.js', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          id: key,
          quantity: quantity
        })
      }).then(function (response) {
        return response.json();
      }).then(function (cart) {
        if (0 == quantity) Render.cartLineItemRemoveByKey(key);
        if (cart.status == 422) {
          Render.cartLineItemErrorMessage(key, cart.message);
          getCart().then(function (cart) {
            updateCartLineQuantityByKey(key, cart.items);
          });
        } else {
          if (cart.item_count > 0) {
            toggleCheckoutButtonUsability('enable');
            toggleCartNoteUsability('enable');
            Render.cartLineItemPrice(key, cart.items);
          } else {
            toggleCheckoutButtonUsability('disable');
            toggleCartNoteUsability('disable');
            Render.cartEmptyMessage();
          }
          Render.cartLineItemsCount(cart.item_count);
          Render.cartSubtotal(cart.items_subtotal_price);
        }
      })["catch"](function (error) {
        console.log('[ changeCartLineItemByKey() ] :: Error', error);
      });
    }
  };
  var updateCartLineQuantityByKey = function updateCartLineQuantityByKey() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var cart_items = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    for (var i = 0; i < cart_items.length; i++) {
      if (key === cart_items[i].key) {
        document.querySelector("[data-key=\"".concat(key, "\"] input[name=\"quantity\"]")).value = cart_items[i].quantity;
        break;
      }
    }
  };
  var updateStepperValue = function updateStepperValue() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var stepper = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (stepper.querySelector('input[name="quantity"]')) {
      stepper.querySelector('input[name="quantity"]').value = value;
    }
  };
  var updateStepperButtonStates = function updateStepperButtonStates() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 99999;
    var stepper = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (stepper) {
      var btnDecrease = stepper.querySelector('.stepper__button.decrease') || false;
      var btnIncrease = stepper.querySelector('.stepper__button.increase') || false;
      if (value == min) {
        btnDecrease.disabled = true;
        btnIncrease.disabled = false;
      } else if (value > min && value < max) {
        btnDecrease.disabled = false;
        btnIncrease.disabled = false;
      } else {
        btnDecrease.disabled = false;
        btnIncrease.disabled = true;
      }
    }
  };
  var init$5 = function init() {
    if (Theme.cart.items.length) {
      toggleCheckoutButtonUsability('enable');
      toggleCartNoteUsability('enable');
    } else {
      Render.cartEmptyMessage();
      toggleCheckoutButtonUsability('disable');
      toggleCartNoteUsability('disable');
    }
    Render.cartLineItemsCount(Theme.cart.item_count);
    Render.cartSubtotal(Theme.cart.items_subtotal_price);
    onClickAddProductToCart();
    onClickRemoveCartLineItem();
    onClickUpdateStepper();
  };
  var Cart = {
    addToCart: addToCart,
    emptyCart: emptyCart,
    getCart: getCart,
    init: init$5
  };

  var info = {
    company: 'The Gift Shop by Very Polite Agency',
    tagline: '"All the Best"',
    version: '2.0'
  };
  var init$4 = function init() {
    console.log("".concat(info.company, " - ").concat(info.tagline, " - Version ").concat(info.version));
    console.log('Site by Very Polite Agency https://weareverypolite.com/');
  };
  var Credits = {
    init: init$4
  };

  var elements$3 = document.querySelectorAll('body, footer, header, main') || [];
  var drawers = {};
  var openDrawerByID = function openDrawerByID() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    setTimeout(function () {
      Tools.addClass("".concat(id, "--active"), elements$3);
    }, delay);
  };
  var toggleDrawerByID = function toggleDrawerByID() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    setTimeout(function () {
      Tools.toggleClass("".concat(id, "--active"), elements$3);
    }, delay);
  };
  var closeDrawerByID = function closeDrawerByID() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    setTimeout(function () {
      Tools.removeClass("".concat(id, "--active"), elements$3);
    }, delay);
  };
  var onClickToggleDrawer = function onClickToggleDrawer() {
    (document.querySelectorAll('.js--toggle-drawer') || []).forEach(function (button) {
      var drawerID = button.dataset.drawerId || '';
      button.addEventListener('click', function (event) {
        toggleDrawerByID(drawerID);
        drawers[drawerID] = drawers !== null && drawers !== void 0 && drawers[drawerID] ? false : true;
      });
    });
  };
  var onClickCloseAllDrawers = function onClickCloseAllDrawers() {
    document.body.addEventListener('click', function (event) {
      var drawer = event.target.closest('.drawer') ? true : false;
      var buttonDrawerOpen = event.target.closest('.js--open-drawer') ? true : false;
      var buttonDrawerClose = event.target.closest('.js--close-drawer') ? true : false;
      var buttonDrawerToggle = event.target.closest('.js--toggle-drawer') ? true : false;
      if (!drawer && !buttonDrawerOpen && !buttonDrawerToggle || buttonDrawerClose) {
        for (var id in drawers) {
          if (drawers[id]) {
            closeDrawerByID(id);
            drawers[id] = false;
          }
        }
      }
    });
  };
  var init$3 = function init() {
    onClickToggleDrawer();
    onClickCloseAllDrawers();
  };
  var Drawers = {
    closeDrawerByID: closeDrawerByID,
    init: init$3,
    openDrawerByID: openDrawerByID
  };

  /*!
   * Glide.js v3.6.0
   * (c) 2013-2022 Jdrzej Chaubek (https://github.com/jedrzejchalubek/)
   * Released under the MIT License.
   */

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  var defaults = {
    /**
     * Type of the movement.
     *
     * Available types:
     * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.
     * `carousel` - Changes slides without starting over when it reaches the first or last slide.
     *
     * @type {String}
     */
    type: 'slider',

    /**
     * Start at specific slide number defined with zero-based index.
     *
     * @type {Number}
     */
    startAt: 0,

    /**
     * A number of slides visible on the single viewport.
     *
     * @type {Number}
     */
    perView: 1,

    /**
     * Focus currently active slide at a specified position in the track.
     *
     * Available inputs:
     * `center` - Current slide will be always focused at the center of a track.
     * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.
     *
     * @type {String|Number}
     */
    focusAt: 0,

    /**
     * A size of the gap added between slides.
     *
     * @type {Number}
     */
    gap: 10,

    /**
     * Change slides after a specified interval. Use `false` for turning off autoplay.
     *
     * @type {Number|Boolean}
     */
    autoplay: false,

    /**
     * Stop autoplay on mouseover event.
     *
     * @type {Boolean}
     */
    hoverpause: true,

    /**
     * Allow for changing slides with left and right keyboard arrows.
     *
     * @type {Boolean}
     */
    keyboard: true,

    /**
     * Stop running `perView` number of slides from the end. Use this
     * option if you don't want to have an empty space after
     * a slider. Works only with `slider` type and a
     * non-centered `focusAt` setting.
     *
     * @type {Boolean}
     */
    bound: false,

    /**
     * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.
     *
     * @type {Number|Boolean}
     */
    swipeThreshold: 80,

    /**
     * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.
     *
     * @type {Number|Boolean}
     */
    dragThreshold: 120,

    /**
     * A number of slides moved on single swipe.
     *
     * Available types:
     * `` - Moves slider by one slide per swipe
     * `|` - Moves slider between views per swipe (number of slides defined in `perView` options)
     *
     * @type {String}
     */
    perSwipe: '',

    /**
     * Moving distance ratio of the slides on a swiping and dragging.
     *
     * @type {Number}
     */
    touchRatio: 0.5,

    /**
     * Angle required to activate slides moving on swiping or dragging.
     *
     * @type {Number}
     */
    touchAngle: 45,

    /**
     * Duration of the animation in milliseconds.
     *
     * @type {Number}
     */
    animationDuration: 400,

    /**
     * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.
     *
     * @type {Boolean}
     */
    rewind: true,

    /**
     * Duration of the rewinding animation of the `slider` type in milliseconds.
     *
     * @type {Number}
     */
    rewindDuration: 800,

    /**
     * Easing function for the animation.
     *
     * @type {String}
     */
    animationTimingFunc: 'cubic-bezier(.165, .840, .440, 1)',

    /**
     * Wait for the animation to finish until the next user input can be processed
     *
     * @type {boolean}
     */
    waitForTransition: true,

    /**
     * Throttle costly events at most once per every wait milliseconds.
     *
     * @type {Number}
     */
    throttle: 10,

    /**
     * Moving direction mode.
     *
     * Available inputs:
     * - 'ltr' - left to right movement,
     * - 'rtl' - right to left movement.
     *
     * @type {String}
     */
    direction: 'ltr',

    /**
     * The distance value of the next and previous viewports which
     * have to peek in the current view. Accepts number and
     * pixels as a string. Left and right peeking can be
     * set up separately with a directions object.
     *
     * For example:
     * `100` - Peek 100px on the both sides.
     * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.
     *
     * @type {Number|String|Object}
     */
    peek: 0,

    /**
     * Defines how many clones of current viewport will be generated.
     *
     * @type {Number}
     */
    cloningRatio: 1,

    /**
     * Collection of options applied at specified media breakpoints.
     * For example: display two slides per view under 800px.
     * `{
     *   '800px': {
     *     perView: 2
     *   }
     * }`
     */
    breakpoints: {},

    /**
     * Collection of internally used HTML classes.
     *
     * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object
     * @type {Object}
     */
    classes: {
      swipeable: 'glide--swipeable',
      dragging: 'glide--dragging',
      direction: {
        ltr: 'glide--ltr',
        rtl: 'glide--rtl'
      },
      type: {
        slider: 'glide--slider',
        carousel: 'glide--carousel'
      },
      slide: {
        clone: 'glide__slide--clone',
        active: 'glide__slide--active'
      },
      arrow: {
        disabled: 'glide__arrow--disabled'
      },
      nav: {
        active: 'glide__bullet--active'
      }
    }
  };

  /**
   * Outputs warning message to the bowser console.
   *
   * @param  {String} msg
   * @return {Void}
   */
  function warn(msg) {
    console.error("[Glide warn]: ".concat(msg));
  }

  /**
   * Converts value entered as number
   * or string to integer value.
   *
   * @param {String} value
   * @returns {Number}
   */
  function toInt(value) {
    return parseInt(value);
  }
  /**
   * Converts value entered as number
   * or string to flat value.
   *
   * @param {String} value
   * @returns {Number}
   */

  function toFloat(value) {
    return parseFloat(value);
  }
  /**
   * Indicates whether the specified value is a string.
   *
   * @param  {*}   value
   * @return {Boolean}
   */

  function isString(value) {
    return typeof value === 'string';
  }
  /**
   * Indicates whether the specified value is an object.
   *
   * @param  {*} value
   * @return {Boolean}
   *
   * @see https://github.com/jashkenas/underscore
   */

  function isObject(value) {
    var type = _typeof(value);

    return type === 'function' || type === 'object' && !!value; // eslint-disable-line no-mixed-operators
  }
  /**
   * Indicates whether the specified value is a function.
   *
   * @param  {*} value
   * @return {Boolean}
   */

  function isFunction(value) {
    return typeof value === 'function';
  }
  /**
   * Indicates whether the specified value is undefined.
   *
   * @param  {*} value
   * @return {Boolean}
   */

  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Indicates whether the specified value is an array.
   *
   * @param  {*} value
   * @return {Boolean}
   */

  function isArray(value) {
    return value.constructor === Array;
  }

  /**
   * Creates and initializes specified collection of extensions.
   * Each extension receives access to instance of glide and rest of components.
   *
   * @param {Object} glide
   * @param {Object} extensions
   *
   * @returns {Object}
   */

  function mount(glide, extensions, events) {
    var components = {};

    for (var name in extensions) {
      if (isFunction(extensions[name])) {
        components[name] = extensions[name](glide, components, events);
      } else {
        warn('Extension must be a function');
      }
    }

    for (var _name in components) {
      if (isFunction(components[_name].mount)) {
        components[_name].mount();
      }
    }

    return components;
  }

  /**
   * Defines getter and setter property on the specified object.
   *
   * @param  {Object} obj         Object where property has to be defined.
   * @param  {String} prop        Name of the defined property.
   * @param  {Object} definition  Get and set definitions for the property.
   * @return {Void}
   */
  function define(obj, prop, definition) {
    Object.defineProperty(obj, prop, definition);
  }
  /**
   * Sorts aphabetically object keys.
   *
   * @param  {Object} obj
   * @return {Object}
   */

  function sortKeys(obj) {
    return Object.keys(obj).sort().reduce(function (r, k) {
      r[k] = obj[k];
      return r[k], r;
    }, {});
  }
  /**
   * Merges passed settings object with default options.
   *
   * @param  {Object} defaults
   * @param  {Object} settings
   * @return {Object}
   */

  function mergeOptions(defaults, settings) {
    var options = Object.assign({}, defaults, settings); // `Object.assign` do not deeply merge objects, so we
    // have to do it manually for every nested object
    // in options. Although it does not look smart,
    // it's smaller and faster than some fancy
    // merging deep-merge algorithm script.

    if (settings.hasOwnProperty('classes')) {
      options.classes = Object.assign({}, defaults.classes, settings.classes);

      if (settings.classes.hasOwnProperty('direction')) {
        options.classes.direction = Object.assign({}, defaults.classes.direction, settings.classes.direction);
      }

      if (settings.classes.hasOwnProperty('type')) {
        options.classes.type = Object.assign({}, defaults.classes.type, settings.classes.type);
      }

      if (settings.classes.hasOwnProperty('slide')) {
        options.classes.slide = Object.assign({}, defaults.classes.slide, settings.classes.slide);
      }

      if (settings.classes.hasOwnProperty('arrow')) {
        options.classes.arrow = Object.assign({}, defaults.classes.arrow, settings.classes.arrow);
      }

      if (settings.classes.hasOwnProperty('nav')) {
        options.classes.nav = Object.assign({}, defaults.classes.nav, settings.classes.nav);
      }
    }

    if (settings.hasOwnProperty('breakpoints')) {
      options.breakpoints = Object.assign({}, defaults.breakpoints, settings.breakpoints);
    }

    return options;
  }

  var EventsBus = /*#__PURE__*/function () {
    /**
     * Construct a EventBus instance.
     *
     * @param {Object} events
     */
    function EventsBus() {
      var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, EventsBus);

      this.events = events;
      this.hop = events.hasOwnProperty;
    }
    /**
     * Adds listener to the specifed event.
     *
     * @param {String|Array} event
     * @param {Function} handler
     */


    _createClass(EventsBus, [{
      key: "on",
      value: function on(event, handler) {
        if (isArray(event)) {
          for (var i = 0; i < event.length; i++) {
            this.on(event[i], handler);
          }

          return;
        } // Create the event's object if not yet created


        if (!this.hop.call(this.events, event)) {
          this.events[event] = [];
        } // Add the handler to queue


        var index = this.events[event].push(handler) - 1; // Provide handle back for removal of event

        return {
          remove: function remove() {
            delete this.events[event][index];
          }
        };
      }
      /**
       * Runs registered handlers for specified event.
       *
       * @param {String|Array} event
       * @param {Object=} context
       */

    }, {
      key: "emit",
      value: function emit(event, context) {
        if (isArray(event)) {
          for (var i = 0; i < event.length; i++) {
            this.emit(event[i], context);
          }

          return;
        } // If the event doesn't exist, or there's no handlers in queue, just leave


        if (!this.hop.call(this.events, event)) {
          return;
        } // Cycle through events queue, fire!


        this.events[event].forEach(function (item) {
          item(context || {});
        });
      }
    }]);

    return EventsBus;
  }();

  var Glide$1 = /*#__PURE__*/function () {
    /**
     * Construct glide.
     *
     * @param  {String} selector
     * @param  {Object} options
     */
    function Glide(selector) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Glide);

      this._c = {};
      this._t = [];
      this._e = new EventsBus();
      this.disabled = false;
      this.selector = selector;
      this.settings = mergeOptions(defaults, options);
      this.index = this.settings.startAt;
    }
    /**
     * Initializes glide.
     *
     * @param {Object} extensions Collection of extensions to initialize.
     * @return {Glide}
     */


    _createClass(Glide, [{
      key: "mount",
      value: function mount$1() {
        var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        this._e.emit('mount.before');

        if (isObject(extensions)) {
          this._c = mount(this, extensions, this._e);
        } else {
          warn('You need to provide a object on `mount()`');
        }

        this._e.emit('mount.after');

        return this;
      }
      /**
       * Collects an instance `translate` transformers.
       *
       * @param  {Array} transformers Collection of transformers.
       * @return {Void}
       */

    }, {
      key: "mutate",
      value: function mutate() {
        var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

        if (isArray(transformers)) {
          this._t = transformers;
        } else {
          warn('You need to provide a array on `mutate()`');
        }

        return this;
      }
      /**
       * Updates glide with specified settings.
       *
       * @param {Object} settings
       * @return {Glide}
       */

    }, {
      key: "update",
      value: function update() {
        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        this.settings = mergeOptions(this.settings, settings);

        if (settings.hasOwnProperty('startAt')) {
          this.index = settings.startAt;
        }

        this._e.emit('update');

        return this;
      }
      /**
       * Change slide with specified pattern. A pattern must be in the special format:
       * `>` - Move one forward
       * `<` - Move one backward
       * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)
       * `>>` - Rewinds to end (last slide)
       * `<<` - Rewinds to start (first slide)
       * `|>` - Move one viewport forward
       * `|<` - Move one viewport backward
       *
       * @param {String} pattern
       * @return {Glide}
       */

    }, {
      key: "go",
      value: function go(pattern) {
        this._c.Run.make(pattern);

        return this;
      }
      /**
       * Move track by specified distance.
       *
       * @param {String} distance
       * @return {Glide}
       */

    }, {
      key: "move",
      value: function move(distance) {
        this._c.Transition.disable();

        this._c.Move.make(distance);

        return this;
      }
      /**
       * Destroy instance and revert all changes done by this._c.
       *
       * @return {Glide}
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this._e.emit('destroy');

        return this;
      }
      /**
       * Start instance autoplaying.
       *
       * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings
       * @return {Glide}
       */

    }, {
      key: "play",
      value: function play() {
        var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (interval) {
          this.settings.autoplay = interval;
        }

        this._e.emit('play');

        return this;
      }
      /**
       * Stop instance autoplaying.
       *
       * @return {Glide}
       */

    }, {
      key: "pause",
      value: function pause() {
        this._e.emit('pause');

        return this;
      }
      /**
       * Sets glide into a idle status.
       *
       * @return {Glide}
       */

    }, {
      key: "disable",
      value: function disable() {
        this.disabled = true;
        return this;
      }
      /**
       * Sets glide into a active status.
       *
       * @return {Glide}
       */

    }, {
      key: "enable",
      value: function enable() {
        this.disabled = false;
        return this;
      }
      /**
       * Adds cuutom event listener with handler.
       *
       * @param  {String|Array} event
       * @param  {Function} handler
       * @return {Glide}
       */

    }, {
      key: "on",
      value: function on(event, handler) {
        this._e.on(event, handler);

        return this;
      }
      /**
       * Checks if glide is a precised type.
       *
       * @param  {String} name
       * @return {Boolean}
       */

    }, {
      key: "isType",
      value: function isType(name) {
        return this.settings.type === name;
      }
      /**
       * Gets value of the core options.
       *
       * @return {Object}
       */

    }, {
      key: "settings",
      get: function get() {
        return this._o;
      }
      /**
       * Sets value of the core options.
       *
       * @param  {Object} o
       * @return {Void}
       */
      ,
      set: function set(o) {
        if (isObject(o)) {
          this._o = o;
        } else {
          warn('Options must be an `object` instance.');
        }
      }
      /**
       * Gets current index of the slider.
       *
       * @return {Object}
       */

    }, {
      key: "index",
      get: function get() {
        return this._i;
      }
      /**
       * Sets current index a slider.
       *
       * @return {Object}
       */
      ,
      set: function set(i) {
        this._i = toInt(i);
      }
      /**
       * Gets type name of the slider.
       *
       * @return {String}
       */

    }, {
      key: "type",
      get: function get() {
        return this.settings.type;
      }
      /**
       * Gets value of the idle status.
       *
       * @return {Boolean}
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._d;
      }
      /**
       * Sets value of the idle status.
       *
       * @return {Boolean}
       */
      ,
      set: function set(status) {
        this._d = !!status;
      }
    }]);

    return Glide;
  }();

  function Run (Glide, Components, Events) {
    var Run = {
      /**
       * Initializes autorunning of the glide.
       *
       * @return {Void}
       */
      mount: function mount() {
        this._o = false;
      },

      /**
       * Makes glides running based on the passed moving schema.
       *
       * @param {String} move
       */
      make: function make(move) {
        var _this = this;

        if (!Glide.disabled) {
          !Glide.settings.waitForTransition || Glide.disable();
          this.move = move;
          Events.emit('run.before', this.move);
          this.calculate();
          Events.emit('run', this.move);
          Components.Transition.after(function () {
            if (_this.isStart()) {
              Events.emit('run.start', _this.move);
            }

            if (_this.isEnd()) {
              Events.emit('run.end', _this.move);
            }

            if (_this.isOffset()) {
              _this._o = false;
              Events.emit('run.offset', _this.move);
            }

            Events.emit('run.after', _this.move);
            Glide.enable();
          });
        }
      },

      /**
       * Calculates current index based on defined move.
       *
       * @return {Number|Undefined}
       */
      calculate: function calculate() {
        var move = this.move,
            length = this.length;
        var steps = move.steps,
            direction = move.direction; // By default assume that size of view is equal to one slide

        var viewSize = 1; // While direction is `=` we want jump to
        // a specified index described in steps.

        if (direction === '=') {
          // Check if bound is true, 
          // as we want to avoid whitespaces.
          if (Glide.settings.bound && toInt(steps) > length) {
            Glide.index = length;
            return;
          }

          Glide.index = steps;
          return;
        } // When pattern is equal to `>>` we want
        // fast forward to the last slide.


        if (direction === '>' && steps === '>') {
          Glide.index = length;
          return;
        } // When pattern is equal to `<<` we want
        // fast forward to the first slide.


        if (direction === '<' && steps === '<') {
          Glide.index = 0;
          return;
        } // pagination movement


        if (direction === '|') {
          viewSize = Glide.settings.perView || 1;
        } // we are moving forward


        if (direction === '>' || direction === '|' && steps === '>') {
          var index = calculateForwardIndex(viewSize);

          if (index > length) {
            this._o = true;
          }

          Glide.index = normalizeForwardIndex(index, viewSize);
          return;
        } // we are moving backward


        if (direction === '<' || direction === '|' && steps === '<') {
          var _index = calculateBackwardIndex(viewSize);

          if (_index < 0) {
            this._o = true;
          }

          Glide.index = normalizeBackwardIndex(_index, viewSize);
          return;
        }

        warn("Invalid direction pattern [".concat(direction).concat(steps, "] has been used"));
      },

      /**
       * Checks if we are on the first slide.
       *
       * @return {Boolean}
       */
      isStart: function isStart() {
        return Glide.index <= 0;
      },

      /**
       * Checks if we are on the last slide.
       *
       * @return {Boolean}
       */
      isEnd: function isEnd() {
        return Glide.index >= this.length;
      },

      /**
       * Checks if we are making a offset run.
       *
       * @param {String} direction
       * @return {Boolean}
       */
      isOffset: function isOffset() {
        var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

        if (!direction) {
          return this._o;
        }

        if (!this._o) {
          return false;
        } // did we view to the right?


        if (direction === '|>') {
          return this.move.direction === '|' && this.move.steps === '>';
        } // did we view to the left?


        if (direction === '|<') {
          return this.move.direction === '|' && this.move.steps === '<';
        }

        return this.move.direction === direction;
      },

      /**
       * Checks if bound mode is active
       *
       * @return {Boolean}
       */
      isBound: function isBound() {
        return Glide.isType('slider') && Glide.settings.focusAt !== 'center' && Glide.settings.bound;
      }
    };
    /**
     * Returns index value to move forward/to the right
     *
     * @param viewSize
     * @returns {Number}
     */

    function calculateForwardIndex(viewSize) {
      var index = Glide.index;

      if (Glide.isType('carousel')) {
        return index + viewSize;
      }

      return index + (viewSize - index % viewSize);
    }
    /**
     * Normalizes the given forward index based on glide settings, preventing it to exceed certain boundaries
     *
     * @param index
     * @param length
     * @param viewSize
     * @returns {Number}
     */


    function normalizeForwardIndex(index, viewSize) {
      var length = Run.length;

      if (index <= length) {
        return index;
      }

      if (Glide.isType('carousel')) {
        return index - (length + 1);
      }

      if (Glide.settings.rewind) {
        // bound does funny things with the length, therefor we have to be certain
        // that we are on the last possible index value given by bound
        if (Run.isBound() && !Run.isEnd()) {
          return length;
        }

        return 0;
      }

      if (Run.isBound()) {
        return length;
      }

      return Math.floor(length / viewSize) * viewSize;
    }
    /**
     * Calculates index value to move backward/to the left
     *
     * @param viewSize
     * @returns {Number}
     */


    function calculateBackwardIndex(viewSize) {
      var index = Glide.index;

      if (Glide.isType('carousel')) {
        return index - viewSize;
      } // ensure our back navigation results in the same index as a forward navigation
      // to experience a homogeneous paging


      var view = Math.ceil(index / viewSize);
      return (view - 1) * viewSize;
    }
    /**
     * Normalizes the given backward index based on glide settings, preventing it to exceed certain boundaries
     *
     * @param index
     * @param length
     * @param viewSize
     * @returns {*}
     */


    function normalizeBackwardIndex(index, viewSize) {
      var length = Run.length;

      if (index >= 0) {
        return index;
      }

      if (Glide.isType('carousel')) {
        return index + (length + 1);
      }

      if (Glide.settings.rewind) {
        // bound does funny things with the length, therefor we have to be certain
        // that we are on first possible index value before we to rewind to the length given by bound
        if (Run.isBound() && Run.isStart()) {
          return length;
        }

        return Math.floor(length / viewSize) * viewSize;
      }

      return 0;
    }

    define(Run, 'move', {
      /**
       * Gets value of the move schema.
       *
       * @returns {Object}
       */
      get: function get() {
        return this._m;
      },

      /**
       * Sets value of the move schema.
       *
       * @returns {Object}
       */
      set: function set(value) {
        var step = value.substr(1);
        this._m = {
          direction: value.substr(0, 1),
          steps: step ? toInt(step) ? toInt(step) : step : 0
        };
      }
    });
    define(Run, 'length', {
      /**
       * Gets value of the running distance based
       * on zero-indexing number of slides.
       *
       * @return {Number}
       */
      get: function get() {
        var settings = Glide.settings;
        var length = Components.Html.slides.length; // If the `bound` option is active, a maximum running distance should be
        // reduced by `perView` and `focusAt` settings. Running distance
        // should end before creating an empty space after instance.

        if (this.isBound()) {
          return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);
        }

        return length - 1;
      }
    });
    define(Run, 'offset', {
      /**
       * Gets status of the offsetting flag.
       *
       * @return {Boolean}
       */
      get: function get() {
        return this._o;
      }
    });
    return Run;
  }

  /**
   * Returns a current time.
   *
   * @return {Number}
   */
  function now() {
    return new Date().getTime();
  }

  /**
   * Returns a function, that, when invoked, will only be triggered
   * at most once during a given window of time.
   *
   * @param {Function} func
   * @param {Number} wait
   * @param {Object=} options
   * @return {Function}
   *
   * @see https://github.com/jashkenas/underscore
   */

  function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function later() {
      previous = options.leading === false ? 0 : now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function throttled() {
      var at = now();
      if (!previous && options.leading === false) previous = at;
      var remaining = wait - (at - previous);
      context = this;
      args = arguments;

      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }

        previous = at;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }

      return result;
    };

    throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  }

  var MARGIN_TYPE = {
    ltr: ['marginLeft', 'marginRight'],
    rtl: ['marginRight', 'marginLeft']
  };
  function Gaps (Glide, Components, Events) {
    var Gaps = {
      /**
       * Applies gaps between slides. First and last
       * slides do not receive it's edge margins.
       *
       * @param {HTMLCollection} slides
       * @return {Void}
       */
      apply: function apply(slides) {
        for (var i = 0, len = slides.length; i < len; i++) {
          var style = slides[i].style;
          var direction = Components.Direction.value;

          if (i !== 0) {
            style[MARGIN_TYPE[direction][0]] = "".concat(this.value / 2, "px");
          } else {
            style[MARGIN_TYPE[direction][0]] = '';
          }

          if (i !== slides.length - 1) {
            style[MARGIN_TYPE[direction][1]] = "".concat(this.value / 2, "px");
          } else {
            style[MARGIN_TYPE[direction][1]] = '';
          }
        }
      },

      /**
       * Removes gaps from the slides.
       *
       * @param {HTMLCollection} slides
       * @returns {Void}
      */
      remove: function remove(slides) {
        for (var i = 0, len = slides.length; i < len; i++) {
          var style = slides[i].style;
          style.marginLeft = '';
          style.marginRight = '';
        }
      }
    };
    define(Gaps, 'value', {
      /**
       * Gets value of the gap.
       *
       * @returns {Number}
       */
      get: function get() {
        return toInt(Glide.settings.gap);
      }
    });
    define(Gaps, 'grow', {
      /**
       * Gets additional dimensions value caused by gaps.
       * Used to increase width of the slides wrapper.
       *
       * @returns {Number}
       */
      get: function get() {
        return Gaps.value * Components.Sizes.length;
      }
    });
    define(Gaps, 'reductor', {
      /**
       * Gets reduction value caused by gaps.
       * Used to subtract width of the slides.
       *
       * @returns {Number}
       */
      get: function get() {
        var perView = Glide.settings.perView;
        return Gaps.value * (perView - 1) / perView;
      }
    });
    /**
     * Apply calculated gaps:
     * - after building, so slides (including clones) will receive proper margins
     * - on updating via API, to recalculate gaps with new options
     */

    Events.on(['build.after', 'update'], throttle(function () {
      Gaps.apply(Components.Html.wrapper.children);
    }, 30));
    /**
     * Remove gaps:
     * - on destroying to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Gaps.remove(Components.Html.wrapper.children);
    });
    return Gaps;
  }

  /**
   * Finds siblings nodes of the passed node.
   *
   * @param  {Element} node
   * @return {Array}
   */
  function siblings(node) {
    if (node && node.parentNode) {
      var n = node.parentNode.firstChild;
      var matched = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== node) {
          matched.push(n);
        }
      }

      return matched;
    }

    return [];
  }
  /**
   * Checks if passed node exist and is a valid element.
   *
   * @param  {Element} node
   * @return {Boolean}
   */

  function exist(node) {
    if (node && node instanceof window.HTMLElement) {
      return true;
    }

    return false;
  }
  /**
   * Coerces a NodeList to an Array.
   *
   * @param  {NodeList} nodeList
   * @return {Array}
   */

  function toArray(nodeList) {
    return Array.prototype.slice.call(nodeList);
  }

  var TRACK_SELECTOR = '[data-glide-el="track"]';
  function Html (Glide, Components, Events) {
    var Html = {
      /**
       * Setup slider HTML nodes.
       *
       * @param {Glide} glide
       */
      mount: function mount() {
        this.root = Glide.selector;
        this.track = this.root.querySelector(TRACK_SELECTOR);
        this.collectSlides();
      },

      /**
       * Collect slides
       */
      collectSlides: function collectSlides() {
        this.slides = toArray(this.wrapper.children).filter(function (slide) {
          return !slide.classList.contains(Glide.settings.classes.slide.clone);
        });
      }
    };
    define(Html, 'root', {
      /**
       * Gets node of the glide main element.
       *
       * @return {Object}
       */
      get: function get() {
        return Html._r;
      },

      /**
       * Sets node of the glide main element.
       *
       * @return {Object}
       */
      set: function set(r) {
        if (isString(r)) {
          r = document.querySelector(r);
        }

        if (exist(r)) {
          Html._r = r;
        } else {
          warn('Root element must be a existing Html node');
        }
      }
    });
    define(Html, 'track', {
      /**
       * Gets node of the glide track with slides.
       *
       * @return {Object}
       */
      get: function get() {
        return Html._t;
      },

      /**
       * Sets node of the glide track with slides.
       *
       * @return {Object}
       */
      set: function set(t) {
        if (exist(t)) {
          Html._t = t;
        } else {
          warn("Could not find track element. Please use ".concat(TRACK_SELECTOR, " attribute."));
        }
      }
    });
    define(Html, 'wrapper', {
      /**
       * Gets node of the slides wrapper.
       *
       * @return {Object}
       */
      get: function get() {
        return Html.track.children[0];
      }
    });
    /**
     * Add/remove/reorder dynamic slides
     */

    Events.on('update', function () {
      Html.collectSlides();
    });
    return Html;
  }

  function Peek (Glide, Components, Events) {
    var Peek = {
      /**
       * Setups how much to peek based on settings.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.value = Glide.settings.peek;
      }
    };
    define(Peek, 'value', {
      /**
       * Gets value of the peek.
       *
       * @returns {Number|Object}
       */
      get: function get() {
        return Peek._v;
      },

      /**
       * Sets value of the peek.
       *
       * @param {Number|Object} value
       * @return {Void}
       */
      set: function set(value) {
        if (isObject(value)) {
          value.before = toInt(value.before);
          value.after = toInt(value.after);
        } else {
          value = toInt(value);
        }

        Peek._v = value;
      }
    });
    define(Peek, 'reductor', {
      /**
       * Gets reduction value caused by peek.
       *
       * @returns {Number}
       */
      get: function get() {
        var value = Peek.value;
        var perView = Glide.settings.perView;

        if (isObject(value)) {
          return value.before / perView + value.after / perView;
        }

        return value * 2 / perView;
      }
    });
    /**
     * Recalculate peeking sizes on:
     * - when resizing window to update to proper percents
     */

    Events.on(['resize', 'update'], function () {
      Peek.mount();
    });
    return Peek;
  }

  function Move (Glide, Components, Events) {
    var Move = {
      /**
       * Constructs move component.
       *
       * @returns {Void}
       */
      mount: function mount() {
        this._o = 0;
      },

      /**
       * Calculates a movement value based on passed offset and currently active index.
       *
       * @param  {Number} offset
       * @return {Void}
       */
      make: function make() {
        var _this = this;

        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.offset = offset;
        Events.emit('move', {
          movement: this.value
        });
        Components.Transition.after(function () {
          Events.emit('move.after', {
            movement: _this.value
          });
        });
      }
    };
    define(Move, 'offset', {
      /**
       * Gets an offset value used to modify current translate.
       *
       * @return {Object}
       */
      get: function get() {
        return Move._o;
      },

      /**
       * Sets an offset value used to modify current translate.
       *
       * @return {Object}
       */
      set: function set(value) {
        Move._o = !isUndefined(value) ? toInt(value) : 0;
      }
    });
    define(Move, 'translate', {
      /**
       * Gets a raw movement value.
       *
       * @return {Number}
       */
      get: function get() {
        return Components.Sizes.slideWidth * Glide.index;
      }
    });
    define(Move, 'value', {
      /**
       * Gets an actual movement value corrected by offset.
       *
       * @return {Number}
       */
      get: function get() {
        var offset = this.offset;
        var translate = this.translate;

        if (Components.Direction.is('rtl')) {
          return translate + offset;
        }

        return translate - offset;
      }
    });
    /**
     * Make movement to proper slide on:
     * - before build, so glide will start at `startAt` index
     * - on each standard run to move to newly calculated index
     */

    Events.on(['build.before', 'run'], function () {
      Move.make();
    });
    return Move;
  }

  function Sizes (Glide, Components, Events) {
    var Sizes = {
      /**
       * Setups dimensions of slides.
       *
       * @return {Void}
       */
      setupSlides: function setupSlides() {
        var width = "".concat(this.slideWidth, "px");
        var slides = Components.Html.slides;

        for (var i = 0; i < slides.length; i++) {
          slides[i].style.width = width;
        }
      },

      /**
       * Setups dimensions of slides wrapper.
       *
       * @return {Void}
       */
      setupWrapper: function setupWrapper() {
        Components.Html.wrapper.style.width = "".concat(this.wrapperSize, "px");
      },

      /**
       * Removes applied styles from HTML elements.
       *
       * @returns {Void}
       */
      remove: function remove() {
        var slides = Components.Html.slides;

        for (var i = 0; i < slides.length; i++) {
          slides[i].style.width = '';
        }

        Components.Html.wrapper.style.width = '';
      }
    };
    define(Sizes, 'length', {
      /**
       * Gets count number of the slides.
       *
       * @return {Number}
       */
      get: function get() {
        return Components.Html.slides.length;
      }
    });
    define(Sizes, 'width', {
      /**
       * Gets width value of the slider (visible area).
       *
       * @return {Number}
       */
      get: function get() {
        return Components.Html.track.offsetWidth;
      }
    });
    define(Sizes, 'wrapperSize', {
      /**
       * Gets size of the slides wrapper.
       *
       * @return {Number}
       */
      get: function get() {
        return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;
      }
    });
    define(Sizes, 'slideWidth', {
      /**
       * Gets width value of a single slide.
       *
       * @return {Number}
       */
      get: function get() {
        return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;
      }
    });
    /**
     * Apply calculated glide's dimensions:
     * - before building, so other dimensions (e.g. translate) will be calculated propertly
     * - when resizing window to recalculate sildes dimensions
     * - on updating via API, to calculate dimensions based on new options
     */

    Events.on(['build.before', 'resize', 'update'], function () {
      Sizes.setupSlides();
      Sizes.setupWrapper();
    });
    /**
     * Remove calculated glide's dimensions:
     * - on destoting to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Sizes.remove();
    });
    return Sizes;
  }

  function Build (Glide, Components, Events) {
    var Build = {
      /**
       * Init glide building. Adds classes, sets
       * dimensions and setups initial state.
       *
       * @return {Void}
       */
      mount: function mount() {
        Events.emit('build.before');
        this.typeClass();
        this.activeClass();
        Events.emit('build.after');
      },

      /**
       * Adds `type` class to the glide element.
       *
       * @return {Void}
       */
      typeClass: function typeClass() {
        Components.Html.root.classList.add(Glide.settings.classes.type[Glide.settings.type]);
      },

      /**
       * Sets active class to current slide.
       *
       * @return {Void}
       */
      activeClass: function activeClass() {
        var classes = Glide.settings.classes;
        var slide = Components.Html.slides[Glide.index];

        if (slide) {
          slide.classList.add(classes.slide.active);
          siblings(slide).forEach(function (sibling) {
            sibling.classList.remove(classes.slide.active);
          });
        }
      },

      /**
       * Removes HTML classes applied at building.
       *
       * @return {Void}
       */
      removeClasses: function removeClasses() {
        var _Glide$settings$class = Glide.settings.classes,
            type = _Glide$settings$class.type,
            slide = _Glide$settings$class.slide;
        Components.Html.root.classList.remove(type[Glide.settings.type]);
        Components.Html.slides.forEach(function (sibling) {
          sibling.classList.remove(slide.active);
        });
      }
    };
    /**
     * Clear building classes:
     * - on destroying to bring HTML to its initial state
     * - on updating to remove classes before remounting component
     */

    Events.on(['destroy', 'update'], function () {
      Build.removeClasses();
    });
    /**
     * Remount component:
     * - on resizing of the window to calculate new dimensions
     * - on updating settings via API
     */

    Events.on(['resize', 'update'], function () {
      Build.mount();
    });
    /**
     * Swap active class of current slide:
     * - after each move to the new index
     */

    Events.on('move.after', function () {
      Build.activeClass();
    });
    return Build;
  }

  function Clones (Glide, Components, Events) {
    var Clones = {
      /**
       * Create pattern map and collect slides to be cloned.
       */
      mount: function mount() {
        this.items = [];

        if (Glide.isType('carousel')) {
          this.items = this.collect();
        }
      },

      /**
       * Collect clones with pattern.
       *
       * @return {[]}
       */
      collect: function collect() {
        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var slides = Components.Html.slides;
        var _Glide$settings = Glide.settings,
            perView = _Glide$settings.perView,
            classes = _Glide$settings.classes,
            cloningRatio = _Glide$settings.cloningRatio;

        if (slides.length !== 0) {
          var peekIncrementer = +!!Glide.settings.peek;
          var cloneCount = perView + peekIncrementer + Math.round(perView / 2);
          var append = slides.slice(0, cloneCount).reverse();
          var prepend = slides.slice(cloneCount * -1);

          for (var r = 0; r < Math.max(cloningRatio, Math.floor(perView / slides.length)); r++) {
            for (var i = 0; i < append.length; i++) {
              var clone = append[i].cloneNode(true);
              clone.classList.add(classes.slide.clone);
              items.push(clone);
            }

            for (var _i = 0; _i < prepend.length; _i++) {
              var _clone = prepend[_i].cloneNode(true);

              _clone.classList.add(classes.slide.clone);

              items.unshift(_clone);
            }
          }
        }

        return items;
      },

      /**
       * Append cloned slides with generated pattern.
       *
       * @return {Void}
       */
      append: function append() {
        var items = this.items;
        var _Components$Html = Components.Html,
            wrapper = _Components$Html.wrapper,
            slides = _Components$Html.slides;
        var half = Math.floor(items.length / 2);
        var prepend = items.slice(0, half).reverse();
        var append = items.slice(half * -1).reverse();
        var width = "".concat(Components.Sizes.slideWidth, "px");

        for (var i = 0; i < append.length; i++) {
          wrapper.appendChild(append[i]);
        }

        for (var _i2 = 0; _i2 < prepend.length; _i2++) {
          wrapper.insertBefore(prepend[_i2], slides[0]);
        }

        for (var _i3 = 0; _i3 < items.length; _i3++) {
          items[_i3].style.width = width;
        }
      },

      /**
       * Remove all cloned slides.
       *
       * @return {Void}
       */
      remove: function remove() {
        var items = this.items;

        for (var i = 0; i < items.length; i++) {
          Components.Html.wrapper.removeChild(items[i]);
        }
      }
    };
    define(Clones, 'grow', {
      /**
       * Gets additional dimensions value caused by clones.
       *
       * @return {Number}
       */
      get: function get() {
        return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;
      }
    });
    /**
     * Append additional slide's clones:
     * - while glide's type is `carousel`
     */

    Events.on('update', function () {
      Clones.remove();
      Clones.mount();
      Clones.append();
    });
    /**
     * Append additional slide's clones:
     * - while glide's type is `carousel`
     */

    Events.on('build.before', function () {
      if (Glide.isType('carousel')) {
        Clones.append();
      }
    });
    /**
     * Remove clones HTMLElements:
     * - on destroying, to bring HTML to its initial state
     */

    Events.on('destroy', function () {
      Clones.remove();
    });
    return Clones;
  }

  var EventsBinder = /*#__PURE__*/function () {
    /**
     * Construct a EventsBinder instance.
     */
    function EventsBinder() {
      var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, EventsBinder);

      this.listeners = listeners;
    }
    /**
     * Adds events listeners to arrows HTML elements.
     *
     * @param  {String|Array} events
     * @param  {Element|Window|Document} el
     * @param  {Function} closure
     * @param  {Boolean|Object} capture
     * @return {Void}
     */


    _createClass(EventsBinder, [{
      key: "on",
      value: function on(events, el, closure) {
        var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        if (isString(events)) {
          events = [events];
        }

        for (var i = 0; i < events.length; i++) {
          this.listeners[events[i]] = closure;
          el.addEventListener(events[i], this.listeners[events[i]], capture);
        }
      }
      /**
       * Removes event listeners from arrows HTML elements.
       *
       * @param  {String|Array} events
       * @param  {Element|Window|Document} el
       * @param  {Boolean|Object} capture
       * @return {Void}
       */

    }, {
      key: "off",
      value: function off(events, el) {
        var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (isString(events)) {
          events = [events];
        }

        for (var i = 0; i < events.length; i++) {
          el.removeEventListener(events[i], this.listeners[events[i]], capture);
        }
      }
      /**
       * Destroy collected listeners.
       *
       * @returns {Void}
       */

    }, {
      key: "destroy",
      value: function destroy() {
        delete this.listeners;
      }
    }]);

    return EventsBinder;
  }();

  function Resize (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Resize = {
      /**
       * Initializes window bindings.
       */
      mount: function mount() {
        this.bind();
      },

      /**
       * Binds `rezsize` listener to the window.
       * It's a costly event, so we are debouncing it.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('resize', window, throttle(function () {
          Events.emit('resize');
        }, Glide.settings.throttle));
      },

      /**
       * Unbinds listeners from the window.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('resize', window);
      }
    };
    /**
     * Remove bindings from window:
     * - on destroying, to remove added EventListener
     */

    Events.on('destroy', function () {
      Resize.unbind();
      Binder.destroy();
    });
    return Resize;
  }

  var VALID_DIRECTIONS = ['ltr', 'rtl'];
  var FLIPED_MOVEMENTS = {
    '>': '<',
    '<': '>',
    '=': '='
  };
  function Direction (Glide, Components, Events) {
    var Direction = {
      /**
       * Setups gap value based on settings.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.value = Glide.settings.direction;
      },

      /**
       * Resolves pattern based on direction value
       *
       * @param {String} pattern
       * @returns {String}
       */
      resolve: function resolve(pattern) {
        var token = pattern.slice(0, 1);

        if (this.is('rtl')) {
          return pattern.split(token).join(FLIPED_MOVEMENTS[token]);
        }

        return pattern;
      },

      /**
       * Checks value of direction mode.
       *
       * @param {String} direction
       * @returns {Boolean}
       */
      is: function is(direction) {
        return this.value === direction;
      },

      /**
       * Applies direction class to the root HTML element.
       *
       * @return {Void}
       */
      addClass: function addClass() {
        Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);
      },

      /**
       * Removes direction class from the root HTML element.
       *
       * @return {Void}
       */
      removeClass: function removeClass() {
        Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);
      }
    };
    define(Direction, 'value', {
      /**
       * Gets value of the direction.
       *
       * @returns {Number}
       */
      get: function get() {
        return Direction._v;
      },

      /**
       * Sets value of the direction.
       *
       * @param {String} value
       * @return {Void}
       */
      set: function set(value) {
        if (VALID_DIRECTIONS.indexOf(value) > -1) {
          Direction._v = value;
        } else {
          warn('Direction value must be `ltr` or `rtl`');
        }
      }
    });
    /**
     * Clear direction class:
     * - on destroy to bring HTML to its initial state
     * - on update to remove class before reappling bellow
     */

    Events.on(['destroy', 'update'], function () {
      Direction.removeClass();
    });
    /**
     * Remount component:
     * - on update to reflect changes in direction value
     */

    Events.on('update', function () {
      Direction.mount();
    });
    /**
     * Apply direction class:
     * - before building to apply class for the first time
     * - on updating to reapply direction class that may changed
     */

    Events.on(['build.before', 'update'], function () {
      Direction.addClass();
    });
    return Direction;
  }

  /**
   * Reflects value of glide movement.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */
  function Rtl (Glide, Components) {
    return {
      /**
       * Negates the passed translate if glide is in RTL option.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        if (Components.Direction.is('rtl')) {
          return -translate;
        }

        return translate;
      }
    };
  }

  /**
   * Updates glide movement with a `gap` settings.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */
  function Gap (Glide, Components) {
    return {
      /**
       * Modifies passed translate value with number in the `gap` settings.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        var multiplier = Math.floor(translate / Components.Sizes.slideWidth);
        return translate + Components.Gaps.value * multiplier;
      }
    };
  }

  /**
   * Updates glide movement with width of additional clones width.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */
  function Grow (Glide, Components) {
    return {
      /**
       * Adds to the passed translate width of the half of clones.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        return translate + Components.Clones.grow / 2;
      }
    };
  }

  /**
   * Updates glide movement with a `peek` settings.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */

  function Peeking (Glide, Components) {
    return {
      /**
       * Modifies passed translate value with a `peek` setting.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        if (Glide.settings.focusAt >= 0) {
          var peek = Components.Peek.value;

          if (isObject(peek)) {
            return translate - peek.before;
          }

          return translate - peek;
        }

        return translate;
      }
    };
  }

  /**
   * Updates glide movement with a `focusAt` settings.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */
  function Focusing (Glide, Components) {
    return {
      /**
       * Modifies passed translate value with index in the `focusAt` setting.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      modify: function modify(translate) {
        var gap = Components.Gaps.value;
        var width = Components.Sizes.width;
        var focusAt = Glide.settings.focusAt;
        var slideWidth = Components.Sizes.slideWidth;

        if (focusAt === 'center') {
          return translate - (width / 2 - slideWidth / 2);
        }

        return translate - slideWidth * focusAt - gap * focusAt;
      }
    };
  }

  /**
   * Applies diffrent transformers on translate value.
   *
   * @param  {Object} Glide
   * @param  {Object} Components
   * @return {Object}
   */

  function mutator (Glide, Components, Events) {
    /**
     * Merge instance transformers with collection of default transformers.
     * It's important that the Rtl component be last on the list,
     * so it reflects all previous transformations.
     *
     * @type {Array}
     */
    var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide._t, [Rtl]);
    return {
      /**
       * Piplines translate value with registered transformers.
       *
       * @param  {Number} translate
       * @return {Number}
       */
      mutate: function mutate(translate) {
        for (var i = 0; i < TRANSFORMERS.length; i++) {
          var transformer = TRANSFORMERS[i];

          if (isFunction(transformer) && isFunction(transformer().modify)) {
            translate = transformer(Glide, Components, Events).modify(translate);
          } else {
            warn('Transformer should be a function that returns an object with `modify()` method');
          }
        }

        return translate;
      }
    };
  }

  function Translate (Glide, Components, Events) {
    var Translate = {
      /**
       * Sets value of translate on HTML element.
       *
       * @param {Number} value
       * @return {Void}
       */
      set: function set(value) {
        var transform = mutator(Glide, Components).mutate(value);
        var translate3d = "translate3d(".concat(-1 * transform, "px, 0px, 0px)");
        Components.Html.wrapper.style.mozTransform = translate3d; // needed for supported Firefox 10-15

        Components.Html.wrapper.style.webkitTransform = translate3d; // needed for supported Chrome 10-35, Safari 5.1-8, and Opera 15-22

        Components.Html.wrapper.style.transform = translate3d;
      },

      /**
       * Removes value of translate from HTML element.
       *
       * @return {Void}
       */
      remove: function remove() {
        Components.Html.wrapper.style.transform = '';
      },

      /**
       * @return {number}
       */
      getStartIndex: function getStartIndex() {
        var length = Components.Sizes.length;
        var index = Glide.index;
        var perView = Glide.settings.perView;

        if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {
          return length + (index - perView);
        } // "modulo length" converts an index that equals length to zero


        return (index + perView) % length;
      },

      /**
       * @return {number}
       */
      getTravelDistance: function getTravelDistance() {
        var travelDistance = Components.Sizes.slideWidth * Glide.settings.perView;

        if (Components.Run.isOffset('>') || Components.Run.isOffset('|>')) {
          // reverse travel distance so that we don't have to change subtract operations
          return travelDistance * -1;
        }

        return travelDistance;
      }
    };
    /**
     * Set new translate value:
     * - on move to reflect index change
     * - on updating via API to reflect possible changes in options
     */

    Events.on('move', function (context) {
      if (!Glide.isType('carousel') || !Components.Run.isOffset()) {
        return Translate.set(context.movement);
      }

      Components.Transition.after(function () {
        Events.emit('translate.jump');
        Translate.set(Components.Sizes.slideWidth * Glide.index);
      });
      var startWidth = Components.Sizes.slideWidth * Components.Translate.getStartIndex();
      return Translate.set(startWidth - Components.Translate.getTravelDistance());
    });
    /**
     * Remove translate:
     * - on destroying to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Translate.remove();
    });
    return Translate;
  }

  function Transition (Glide, Components, Events) {
    /**
     * Holds inactivity status of transition.
     * When true transition is not applied.
     *
     * @type {Boolean}
     */
    var disabled = false;
    var Transition = {
      /**
       * Composes string of the CSS transition.
       *
       * @param {String} property
       * @return {String}
       */
      compose: function compose(property) {
        var settings = Glide.settings;

        if (!disabled) {
          return "".concat(property, " ").concat(this.duration, "ms ").concat(settings.animationTimingFunc);
        }

        return "".concat(property, " 0ms ").concat(settings.animationTimingFunc);
      },

      /**
       * Sets value of transition on HTML element.
       *
       * @param {String=} property
       * @return {Void}
       */
      set: function set() {
        var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';
        Components.Html.wrapper.style.transition = this.compose(property);
      },

      /**
       * Removes value of transition from HTML element.
       *
       * @return {Void}
       */
      remove: function remove() {
        Components.Html.wrapper.style.transition = '';
      },

      /**
       * Runs callback after animation.
       *
       * @param  {Function} callback
       * @return {Void}
       */
      after: function after(callback) {
        setTimeout(function () {
          callback();
        }, this.duration);
      },

      /**
       * Enable transition.
       *
       * @return {Void}
       */
      enable: function enable() {
        disabled = false;
        this.set();
      },

      /**
       * Disable transition.
       *
       * @return {Void}
       */
      disable: function disable() {
        disabled = true;
        this.set();
      }
    };
    define(Transition, 'duration', {
      /**
       * Gets duration of the transition based
       * on currently running animation type.
       *
       * @return {Number}
       */
      get: function get() {
        var settings = Glide.settings;

        if (Glide.isType('slider') && Components.Run.offset) {
          return settings.rewindDuration;
        }

        return settings.animationDuration;
      }
    });
    /**
     * Set transition `style` value:
     * - on each moving, because it may be cleared by offset move
     */

    Events.on('move', function () {
      Transition.set();
    });
    /**
     * Disable transition:
     * - before initial build to avoid transitioning from `0` to `startAt` index
     * - while resizing window and recalculating dimensions
     * - on jumping from offset transition at start and end edges in `carousel` type
     */

    Events.on(['build.before', 'resize', 'translate.jump'], function () {
      Transition.disable();
    });
    /**
     * Enable transition:
     * - on each running, because it may be disabled by offset move
     */

    Events.on('run', function () {
      Transition.enable();
    });
    /**
     * Remove transition:
     * - on destroying to bring markup to its inital state
     */

    Events.on('destroy', function () {
      Transition.remove();
    });
    return Transition;
  }

  /**
   * Test via a getter in the options object to see
   * if the passive property is accessed.
   *
   * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection
   */
  var supportsPassive = false;

  try {
    var opts = Object.defineProperty({}, 'passive', {
      get: function get() {
        supportsPassive = true;
      }
    });
    window.addEventListener('testPassive', null, opts);
    window.removeEventListener('testPassive', null, opts);
  } catch (e) {}

  var supportsPassive$1 = supportsPassive;

  var START_EVENTS = ['touchstart', 'mousedown'];
  var MOVE_EVENTS = ['touchmove', 'mousemove'];
  var END_EVENTS = ['touchend', 'touchcancel', 'mouseup', 'mouseleave'];
  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];
  function Swipe (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var swipeSin = 0;
    var swipeStartX = 0;
    var swipeStartY = 0;
    var disabled = false;
    var capture = supportsPassive$1 ? {
      passive: true
    } : false;
    var Swipe = {
      /**
       * Initializes swipe bindings.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.bindSwipeStart();
      },

      /**
       * Handler for `swipestart` event. Calculates entry points of the user's tap.
       *
       * @param {Object} event
       * @return {Void}
       */
      start: function start(event) {
        if (!disabled && !Glide.disabled) {
          this.disable();
          var swipe = this.touches(event);
          swipeSin = null;
          swipeStartX = toInt(swipe.pageX);
          swipeStartY = toInt(swipe.pageY);
          this.bindSwipeMove();
          this.bindSwipeEnd();
          Events.emit('swipe.start');
        }
      },

      /**
       * Handler for `swipemove` event. Calculates user's tap angle and distance.
       *
       * @param {Object} event
       */
      move: function move(event) {
        if (!Glide.disabled) {
          var _Glide$settings = Glide.settings,
              touchAngle = _Glide$settings.touchAngle,
              touchRatio = _Glide$settings.touchRatio,
              classes = _Glide$settings.classes;
          var swipe = this.touches(event);
          var subExSx = toInt(swipe.pageX) - swipeStartX;
          var subEySy = toInt(swipe.pageY) - swipeStartY;
          var powEX = Math.abs(subExSx << 2);
          var powEY = Math.abs(subEySy << 2);
          var swipeHypotenuse = Math.sqrt(powEX + powEY);
          var swipeCathetus = Math.sqrt(powEY);
          swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);

          if (swipeSin * 180 / Math.PI < touchAngle) {
            event.stopPropagation();
            Components.Move.make(subExSx * toFloat(touchRatio));
            Components.Html.root.classList.add(classes.dragging);
            Events.emit('swipe.move');
          } else {
            return false;
          }
        }
      },

      /**
       * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.
       *
       * @param {Object} event
       * @return {Void}
       */
      end: function end(event) {
        if (!Glide.disabled) {
          var _Glide$settings2 = Glide.settings,
              perSwipe = _Glide$settings2.perSwipe,
              touchAngle = _Glide$settings2.touchAngle,
              classes = _Glide$settings2.classes;
          var swipe = this.touches(event);
          var threshold = this.threshold(event);
          var swipeDistance = swipe.pageX - swipeStartX;
          var swipeDeg = swipeSin * 180 / Math.PI;
          this.enable();

          if (swipeDistance > threshold && swipeDeg < touchAngle) {
            Components.Run.make(Components.Direction.resolve("".concat(perSwipe, "<")));
          } else if (swipeDistance < -threshold && swipeDeg < touchAngle) {
            Components.Run.make(Components.Direction.resolve("".concat(perSwipe, ">")));
          } else {
            // While swipe don't reach distance apply previous transform.
            Components.Move.make();
          }

          Components.Html.root.classList.remove(classes.dragging);
          this.unbindSwipeMove();
          this.unbindSwipeEnd();
          Events.emit('swipe.end');
        }
      },

      /**
       * Binds swipe's starting event.
       *
       * @return {Void}
       */
      bindSwipeStart: function bindSwipeStart() {
        var _this = this;

        var _Glide$settings3 = Glide.settings,
            swipeThreshold = _Glide$settings3.swipeThreshold,
            dragThreshold = _Glide$settings3.dragThreshold;

        if (swipeThreshold) {
          Binder.on(START_EVENTS[0], Components.Html.wrapper, function (event) {
            _this.start(event);
          }, capture);
        }

        if (dragThreshold) {
          Binder.on(START_EVENTS[1], Components.Html.wrapper, function (event) {
            _this.start(event);
          }, capture);
        }
      },

      /**
       * Unbinds swipe's starting event.
       *
       * @return {Void}
       */
      unbindSwipeStart: function unbindSwipeStart() {
        Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);
        Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);
      },

      /**
       * Binds swipe's moving event.
       *
       * @return {Void}
       */
      bindSwipeMove: function bindSwipeMove() {
        var _this2 = this;

        Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {
          _this2.move(event);
        }, Glide.settings.throttle), capture);
      },

      /**
       * Unbinds swipe's moving event.
       *
       * @return {Void}
       */
      unbindSwipeMove: function unbindSwipeMove() {
        Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);
      },

      /**
       * Binds swipe's ending event.
       *
       * @return {Void}
       */
      bindSwipeEnd: function bindSwipeEnd() {
        var _this3 = this;

        Binder.on(END_EVENTS, Components.Html.wrapper, function (event) {
          _this3.end(event);
        });
      },

      /**
       * Unbinds swipe's ending event.
       *
       * @return {Void}
       */
      unbindSwipeEnd: function unbindSwipeEnd() {
        Binder.off(END_EVENTS, Components.Html.wrapper);
      },

      /**
       * Normalizes event touches points accorting to different types.
       *
       * @param {Object} event
       */
      touches: function touches(event) {
        if (MOUSE_EVENTS.indexOf(event.type) > -1) {
          return event;
        }

        return event.touches[0] || event.changedTouches[0];
      },

      /**
       * Gets value of minimum swipe distance settings based on event type.
       *
       * @return {Number}
       */
      threshold: function threshold(event) {
        var settings = Glide.settings;

        if (MOUSE_EVENTS.indexOf(event.type) > -1) {
          return settings.dragThreshold;
        }

        return settings.swipeThreshold;
      },

      /**
       * Enables swipe event.
       *
       * @return {self}
       */
      enable: function enable() {
        disabled = false;
        Components.Transition.enable();
        return this;
      },

      /**
       * Disables swipe event.
       *
       * @return {self}
       */
      disable: function disable() {
        disabled = true;
        Components.Transition.disable();
        return this;
      }
    };
    /**
     * Add component class:
     * - after initial building
     */

    Events.on('build.after', function () {
      Components.Html.root.classList.add(Glide.settings.classes.swipeable);
    });
    /**
     * Remove swiping bindings:
     * - on destroying, to remove added EventListeners
     */

    Events.on('destroy', function () {
      Swipe.unbindSwipeStart();
      Swipe.unbindSwipeMove();
      Swipe.unbindSwipeEnd();
      Binder.destroy();
    });
    return Swipe;
  }

  function Images (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Images = {
      /**
       * Binds listener to glide wrapper.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.bind();
      },

      /**
       * Binds `dragstart` event on wrapper to prevent dragging images.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('dragstart', Components.Html.wrapper, this.dragstart);
      },

      /**
       * Unbinds `dragstart` event on wrapper.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('dragstart', Components.Html.wrapper);
      },

      /**
       * Event handler. Prevents dragging.
       *
       * @return {Void}
       */
      dragstart: function dragstart(event) {
        event.preventDefault();
      }
    };
    /**
     * Remove bindings from images:
     * - on destroying, to remove added EventListeners
     */

    Events.on('destroy', function () {
      Images.unbind();
      Binder.destroy();
    });
    return Images;
  }

  function Anchors (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    /**
     * Holds detaching status of anchors.
     * Prevents detaching of already detached anchors.
     *
     * @private
     * @type {Boolean}
     */

    var detached = false;
    /**
     * Holds preventing status of anchors.
     * If `true` redirection after click will be disabled.
     *
     * @private
     * @type {Boolean}
     */

    var prevented = false;
    var Anchors = {
      /**
       * Setups a initial state of anchors component.
       *
       * @returns {Void}
       */
      mount: function mount() {
        /**
         * Holds collection of anchors elements.
         *
         * @private
         * @type {HTMLCollection}
         */
        this._a = Components.Html.wrapper.querySelectorAll('a');
        this.bind();
      },

      /**
       * Binds events to anchors inside a track.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('click', Components.Html.wrapper, this.click);
      },

      /**
       * Unbinds events attached to anchors inside a track.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('click', Components.Html.wrapper);
      },

      /**
       * Handler for click event. Prevents clicks when glide is in `prevent` status.
       *
       * @param  {Object} event
       * @return {Void}
       */
      click: function click(event) {
        if (prevented) {
          event.stopPropagation();
          event.preventDefault();
        }
      },

      /**
       * Detaches anchors click event inside glide.
       *
       * @return {self}
       */
      detach: function detach() {
        prevented = true;

        if (!detached) {
          for (var i = 0; i < this.items.length; i++) {
            this.items[i].draggable = false;
          }

          detached = true;
        }

        return this;
      },

      /**
       * Attaches anchors click events inside glide.
       *
       * @return {self}
       */
      attach: function attach() {
        prevented = false;

        if (detached) {
          for (var i = 0; i < this.items.length; i++) {
            this.items[i].draggable = true;
          }

          detached = false;
        }

        return this;
      }
    };
    define(Anchors, 'items', {
      /**
       * Gets collection of the arrows HTML elements.
       *
       * @return {HTMLElement[]}
       */
      get: function get() {
        return Anchors._a;
      }
    });
    /**
     * Detach anchors inside slides:
     * - on swiping, so they won't redirect to its `href` attributes
     */

    Events.on('swipe.move', function () {
      Anchors.detach();
    });
    /**
     * Attach anchors inside slides:
     * - after swiping and transitions ends, so they can redirect after click again
     */

    Events.on('swipe.end', function () {
      Components.Transition.after(function () {
        Anchors.attach();
      });
    });
    /**
     * Unbind anchors inside slides:
     * - on destroying, to bring anchors to its initial state
     */

    Events.on('destroy', function () {
      Anchors.attach();
      Anchors.unbind();
      Binder.destroy();
    });
    return Anchors;
  }

  var NAV_SELECTOR = '[data-glide-el="controls[nav]"]';
  var CONTROLS_SELECTOR = '[data-glide-el^="controls"]';
  var PREVIOUS_CONTROLS_SELECTOR = "".concat(CONTROLS_SELECTOR, " [data-glide-dir*=\"<\"]");
  var NEXT_CONTROLS_SELECTOR = "".concat(CONTROLS_SELECTOR, " [data-glide-dir*=\">\"]");
  function Controls (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var capture = supportsPassive$1 ? {
      passive: true
    } : false;
    var Controls = {
      /**
       * Inits arrows. Binds events listeners
       * to the arrows HTML elements.
       *
       * @return {Void}
       */
      mount: function mount() {
        /**
         * Collection of navigation HTML elements.
         *
         * @private
         * @type {HTMLCollection}
         */
        this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);
        /**
         * Collection of controls HTML elements.
         *
         * @private
         * @type {HTMLCollection}
         */

        this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);
        /**
         * Collection of arrow control HTML elements.
         *
         * @private
         * @type {Object}
         */

        this._arrowControls = {
          previous: Components.Html.root.querySelectorAll(PREVIOUS_CONTROLS_SELECTOR),
          next: Components.Html.root.querySelectorAll(NEXT_CONTROLS_SELECTOR)
        };
        this.addBindings();
      },

      /**
       * Sets active class to current slide.
       *
       * @return {Void}
       */
      setActive: function setActive() {
        for (var i = 0; i < this._n.length; i++) {
          this.addClass(this._n[i].children);
        }
      },

      /**
       * Removes active class to current slide.
       *
       * @return {Void}
       */
      removeActive: function removeActive() {
        for (var i = 0; i < this._n.length; i++) {
          this.removeClass(this._n[i].children);
        }
      },

      /**
       * Toggles active class on items inside navigation.
       *
       * @param  {HTMLElement} controls
       * @return {Void}
       */
      addClass: function addClass(controls) {
        var settings = Glide.settings;
        var item = controls[Glide.index];

        if (!item) {
          return;
        }

        if (item) {
          item.classList.add(settings.classes.nav.active);
          siblings(item).forEach(function (sibling) {
            sibling.classList.remove(settings.classes.nav.active);
          });
        }
      },

      /**
       * Removes active class from active control.
       *
       * @param  {HTMLElement} controls
       * @return {Void}
       */
      removeClass: function removeClass(controls) {
        var item = controls[Glide.index];

        if (item) {
          item.classList.remove(Glide.settings.classes.nav.active);
        }
      },

      /**
       * Calculates, removes or adds `Glide.settings.classes.disabledArrow` class on the control arrows
       */
      setArrowState: function setArrowState() {
        if (Glide.settings.rewind) {
          return;
        }

        var next = Controls._arrowControls.next;
        var previous = Controls._arrowControls.previous;
        this.resetArrowState(next, previous);

        if (Glide.index === 0) {
          this.disableArrow(previous);
        }

        if (Glide.index === Components.Run.length) {
          this.disableArrow(next);
        }
      },

      /**
       * Removes `Glide.settings.classes.disabledArrow` from given NodeList elements
       *
       * @param {NodeList[]} lists
       */
      resetArrowState: function resetArrowState() {
        var settings = Glide.settings;

        for (var _len = arguments.length, lists = new Array(_len), _key = 0; _key < _len; _key++) {
          lists[_key] = arguments[_key];
        }

        lists.forEach(function (list) {
          toArray(list).forEach(function (element) {
            element.classList.remove(settings.classes.arrow.disabled);
          });
        });
      },

      /**
       * Adds `Glide.settings.classes.disabledArrow` to given NodeList elements
       *
       * @param {NodeList[]} lists
       */
      disableArrow: function disableArrow() {
        var settings = Glide.settings;

        for (var _len2 = arguments.length, lists = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          lists[_key2] = arguments[_key2];
        }

        lists.forEach(function (list) {
          toArray(list).forEach(function (element) {
            element.classList.add(settings.classes.arrow.disabled);
          });
        });
      },

      /**
       * Adds handles to the each group of controls.
       *
       * @return {Void}
       */
      addBindings: function addBindings() {
        for (var i = 0; i < this._c.length; i++) {
          this.bind(this._c[i].children);
        }
      },

      /**
       * Removes handles from the each group of controls.
       *
       * @return {Void}
       */
      removeBindings: function removeBindings() {
        for (var i = 0; i < this._c.length; i++) {
          this.unbind(this._c[i].children);
        }
      },

      /**
       * Binds events to arrows HTML elements.
       *
       * @param {HTMLCollection} elements
       * @return {Void}
       */
      bind: function bind(elements) {
        for (var i = 0; i < elements.length; i++) {
          Binder.on('click', elements[i], this.click);
          Binder.on('touchstart', elements[i], this.click, capture);
        }
      },

      /**
       * Unbinds events binded to the arrows HTML elements.
       *
       * @param {HTMLCollection} elements
       * @return {Void}
       */
      unbind: function unbind(elements) {
        for (var i = 0; i < elements.length; i++) {
          Binder.off(['click', 'touchstart'], elements[i]);
        }
      },

      /**
       * Handles `click` event on the arrows HTML elements.
       * Moves slider in direction given via the
       * `data-glide-dir` attribute.
       *
       * @param {Object} event
       * @return {void}
       */
      click: function click(event) {
        if (!supportsPassive$1 && event.type === 'touchstart') {
          event.preventDefault();
        }

        var direction = event.currentTarget.getAttribute('data-glide-dir');
        Components.Run.make(Components.Direction.resolve(direction));
      }
    };
    define(Controls, 'items', {
      /**
       * Gets collection of the controls HTML elements.
       *
       * @return {HTMLElement[]}
       */
      get: function get() {
        return Controls._c;
      }
    });
    /**
     * Swap active class of current navigation item:
     * - after mounting to set it to initial index
     * - after each move to the new index
     */

    Events.on(['mount.after', 'move.after'], function () {
      Controls.setActive();
    });
    /**
     * Add or remove disabled class of arrow elements
     */

    Events.on(['mount.after', 'run'], function () {
      Controls.setArrowState();
    });
    /**
     * Remove bindings and HTML Classes:
     * - on destroying, to bring markup to its initial state
     */

    Events.on('destroy', function () {
      Controls.removeBindings();
      Controls.removeActive();
      Binder.destroy();
    });
    return Controls;
  }

  function Keyboard (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Keyboard = {
      /**
       * Binds keyboard events on component mount.
       *
       * @return {Void}
       */
      mount: function mount() {
        if (Glide.settings.keyboard) {
          this.bind();
        }
      },

      /**
       * Adds keyboard press events.
       *
       * @return {Void}
       */
      bind: function bind() {
        Binder.on('keyup', document, this.press);
      },

      /**
       * Removes keyboard press events.
       *
       * @return {Void}
       */
      unbind: function unbind() {
        Binder.off('keyup', document);
      },

      /**
       * Handles keyboard's arrows press and moving glide foward and backward.
       *
       * @param  {Object} event
       * @return {Void}
       */
      press: function press(event) {
        var perSwipe = Glide.settings.perSwipe;

        if (event.code === 'ArrowRight') {
          Components.Run.make(Components.Direction.resolve("".concat(perSwipe, ">")));
        }

        if (event.code === 'ArrowLeft') {
          Components.Run.make(Components.Direction.resolve("".concat(perSwipe, "<")));
        }
      }
    };
    /**
     * Remove bindings from keyboard:
     * - on destroying to remove added events
     * - on updating to remove events before remounting
     */

    Events.on(['destroy', 'update'], function () {
      Keyboard.unbind();
    });
    /**
     * Remount component
     * - on updating to reflect potential changes in settings
     */

    Events.on('update', function () {
      Keyboard.mount();
    });
    /**
     * Destroy binder:
     * - on destroying to remove listeners
     */

    Events.on('destroy', function () {
      Binder.destroy();
    });
    return Keyboard;
  }

  function Autoplay (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    var Autoplay = {
      /**
       * Initializes autoplaying and events.
       *
       * @return {Void}
       */
      mount: function mount() {
        this.enable();
        this.start();

        if (Glide.settings.hoverpause) {
          this.bind();
        }
      },

      /**
       * Enables autoplaying
       *
       * @returns {Void}
       */
      enable: function enable() {
        this._e = true;
      },

      /**
       * Disables autoplaying.
       *
       * @returns {Void}
       */
      disable: function disable() {
        this._e = false;
      },

      /**
       * Starts autoplaying in configured interval.
       *
       * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings
       * @return {Void}
       */
      start: function start() {
        var _this = this;

        if (!this._e) {
          return;
        }

        this.enable();

        if (Glide.settings.autoplay) {
          if (isUndefined(this._i)) {
            this._i = setInterval(function () {
              _this.stop();

              Components.Run.make('>');

              _this.start();

              Events.emit('autoplay');
            }, this.time);
          }
        }
      },

      /**
       * Stops autorunning of the glide.
       *
       * @return {Void}
       */
      stop: function stop() {
        this._i = clearInterval(this._i);
      },

      /**
       * Stops autoplaying while mouse is over glide's area.
       *
       * @return {Void}
       */
      bind: function bind() {
        var _this2 = this;

        Binder.on('mouseover', Components.Html.root, function () {
          if (_this2._e) {
            _this2.stop();
          }
        });
        Binder.on('mouseout', Components.Html.root, function () {
          if (_this2._e) {
            _this2.start();
          }
        });
      },

      /**
       * Unbind mouseover events.
       *
       * @returns {Void}
       */
      unbind: function unbind() {
        Binder.off(['mouseover', 'mouseout'], Components.Html.root);
      }
    };
    define(Autoplay, 'time', {
      /**
       * Gets time period value for the autoplay interval. Prioritizes
       * times in `data-glide-autoplay` attrubutes over options.
       *
       * @return {Number}
       */
      get: function get() {
        var autoplay = Components.Html.slides[Glide.index].getAttribute('data-glide-autoplay');

        if (autoplay) {
          return toInt(autoplay);
        }

        return toInt(Glide.settings.autoplay);
      }
    });
    /**
     * Stop autoplaying and unbind events:
     * - on destroying, to clear defined interval
     * - on updating via API to reset interval that may changed
     */

    Events.on(['destroy', 'update'], function () {
      Autoplay.unbind();
    });
    /**
     * Stop autoplaying:
     * - before each run, to restart autoplaying
     * - on pausing via API
     * - on destroying, to clear defined interval
     * - while starting a swipe
     * - on updating via API to reset interval that may changed
     */

    Events.on(['run.before', 'swipe.start', 'update'], function () {
      Autoplay.stop();
    });
    Events.on(['pause', 'destroy'], function () {
      Autoplay.disable();
      Autoplay.stop();
    });
    /**
     * Start autoplaying:
     * - after each run, to restart autoplaying
     * - on playing via API
     * - while ending a swipe
     */

    Events.on(['run.after', 'swipe.end'], function () {
      Autoplay.start();
    });
    /**
     * Start autoplaying:
     * - after each run, to restart autoplaying
     * - on playing via API
     * - while ending a swipe
     */

    Events.on(['play'], function () {
      Autoplay.enable();
      Autoplay.start();
    });
    /**
     * Remount autoplaying:
     * - on updating via API to reset interval that may changed
     */

    Events.on('update', function () {
      Autoplay.mount();
    });
    /**
     * Destroy a binder:
     * - on destroying glide instance to clearup listeners
     */

    Events.on('destroy', function () {
      Binder.destroy();
    });
    return Autoplay;
  }

  /**
   * Sorts keys of breakpoint object so they will be ordered from lower to bigger.
   *
   * @param {Object} points
   * @returns {Object}
   */

  function sortBreakpoints(points) {
    if (isObject(points)) {
      return sortKeys(points);
    } else {
      warn("Breakpoints option must be an object");
    }

    return {};
  }

  function Breakpoints (Glide, Components, Events) {
    /**
     * Instance of the binder for DOM Events.
     *
     * @type {EventsBinder}
     */
    var Binder = new EventsBinder();
    /**
     * Holds reference to settings.
     *
     * @type {Object}
     */

    var settings = Glide.settings;
    /**
     * Holds reference to breakpoints object in settings. Sorts breakpoints
     * from smaller to larger. It is required in order to proper
     * matching currently active breakpoint settings.
     *
     * @type {Object}
     */

    var points = sortBreakpoints(settings.breakpoints);
    /**
     * Cache initial settings before overwritting.
     *
     * @type {Object}
     */

    var defaults = Object.assign({}, settings);
    var Breakpoints = {
      /**
       * Matches settings for currectly matching media breakpoint.
       *
       * @param {Object} points
       * @returns {Object}
       */
      match: function match(points) {
        if (typeof window.matchMedia !== 'undefined') {
          for (var point in points) {
            if (points.hasOwnProperty(point)) {
              if (window.matchMedia("(max-width: ".concat(point, "px)")).matches) {
                return points[point];
              }
            }
          }
        }

        return defaults;
      }
    };
    /**
     * Overwrite instance settings with currently matching breakpoint settings.
     * This happens right after component initialization.
     */

    Object.assign(settings, Breakpoints.match(points));
    /**
     * Update glide with settings of matched brekpoint:
     * - window resize to update slider
     */

    Binder.on('resize', window, throttle(function () {
      Glide.settings = mergeOptions(settings, Breakpoints.match(points));
    }, Glide.settings.throttle));
    /**
     * Resort and update default settings:
     * - on reinit via API, so breakpoint matching will be performed with options
     */

    Events.on('update', function () {
      points = sortBreakpoints(points);
      defaults = Object.assign({}, settings);
    });
    /**
     * Unbind resize listener:
     * - on destroying, to bring markup to its initial state
     */

    Events.on('destroy', function () {
      Binder.off('resize', window);
    });
    return Breakpoints;
  }

  var COMPONENTS = {
    // Required
    Html: Html,
    Translate: Translate,
    Transition: Transition,
    Direction: Direction,
    Peek: Peek,
    Sizes: Sizes,
    Gaps: Gaps,
    Move: Move,
    Clones: Clones,
    Resize: Resize,
    Build: Build,
    Run: Run,
    // Optional
    Swipe: Swipe,
    Images: Images,
    Anchors: Anchors,
    Controls: Controls,
    Keyboard: Keyboard,
    Autoplay: Autoplay,
    Breakpoints: Breakpoints
  };

  var Glide = /*#__PURE__*/function (_Core) {
    _inherits(Glide, _Core);

    var _super = _createSuper(Glide);

    function Glide() {
      _classCallCheck(this, Glide);

      return _super.apply(this, arguments);
    }

    _createClass(Glide, [{
      key: "mount",
      value: function mount() {
        var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return _get(_getPrototypeOf(Glide.prototype), "mount", this).call(this, Object.assign({}, COMPONENTS, extensions));
      }
    }]);

    return Glide;
  }(Glide$1);

  var events = ["build.after", "run.after"];
  var elements$2 = document.querySelectorAll('.js--glide') || [];
  var gliders = {};
  var createGliderFromElement = function createGliderFromElement() {
    var _element$id, _element$dataset$glid, _element$dataset, _element$dataset$glid2, _element$dataset2, _element$dataset$glid3, _element$dataset3, _element$dataset$glid4, _element$dataset4, _element$dataset$glid5, _element$dataset5;
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var element_id = (_element$id = element === null || element === void 0 ? void 0 : element.id) !== null && _element$id !== void 0 ? _element$id : '';
    var animationDuration = parseInt((_element$dataset$glid = (_element$dataset = element.dataset) === null || _element$dataset === void 0 ? void 0 : _element$dataset.glideAnimationDuration) !== null && _element$dataset$glid !== void 0 ? _element$dataset$glid : 450);
    var autoplay = parseInt((_element$dataset$glid2 = (_element$dataset2 = element.dataset) === null || _element$dataset2 === void 0 ? void 0 : _element$dataset2.glideAutoplay) !== null && _element$dataset$glid2 !== void 0 ? _element$dataset$glid2 : 3500);
    var direction = (_element$dataset$glid3 = (_element$dataset3 = element.dataset) === null || _element$dataset3 === void 0 ? void 0 : _element$dataset3.glideDirection) !== null && _element$dataset$glid3 !== void 0 ? _element$dataset$glid3 : 'rtl';
    var gap = parseInt((_element$dataset$glid4 = (_element$dataset4 = element.dataset) === null || _element$dataset4 === void 0 ? void 0 : _element$dataset4.glideGap) !== null && _element$dataset$glid4 !== void 0 ? _element$dataset$glid4 : 36);
    var style = (_element$dataset$glid5 = (_element$dataset5 = element.dataset) === null || _element$dataset5 === void 0 ? void 0 : _element$dataset5.glideStyle) !== null && _element$dataset$glid5 !== void 0 ? _element$dataset$glid5 : '';
    var options = getOptions({
      animationDuration: animationDuration,
      autoplay: autoplay,
      direction: direction,
      gap: gap
    });
    switch (style) {
      case 'announcements':
        {
          options.hoverpause = true;
          break;
        }
    }
    var glide = new Glide("#" + element_id, options);
    glide.on(events, function (event) {
      switch (style) {
        case 'product-image-gallery-carousel':
          {
            updateProductGalleryModalTrigger(glide.index);
            break;
          }
        default:
          {
            setTimeout(function () {
              return updateGlideTrackHeight(element);
            }, 100);
            break;
          }
      }
    });
    (document.querySelectorAll('[data-glide-navigation="#' + element_id + '"].next, [data-target="#' + element_id + '"].next') || []).forEach(function (button) {
      button.addEventListener("click", function () {
        glide.go(">");
      });
    });
    (document.querySelectorAll('[data-glide-navigation="#' + element_id + '"].prev, [data-target="#' + element_id + '"].prev') || []).forEach(function (button) {
      button.addEventListener("click", function () {
        glide.go("<");
      });
    });
    glide.mount();
    setTimeout(function () {
      glide.update();
    }, 250);
    gliders[element_id] = {
      element_id: element_id,
      glide: glide
    };
  };
  var getOptions = function getOptions() {
    var custom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var standard = {
      animationTimingFunc: "ease-in-out",
      animationDuration: 350,
      autoHeight: true,
      autoplay: 3250,
      direction: 'rtl',
      dragThreshold: 35,
      hoverpause: false,
      perView: 1,
      swipeThreshold: 35,
      type: "carousel",
      rewind: true,
      throttle: 50,
      gap: 0
    };
    return _objectSpread2(_objectSpread2({}, standard), custom);
  };
  var updateGlideTrackHeight = function updateGlideTrackHeight() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (element) {
      var active_slide = element.querySelector('.glide__slide--active') || false;
      var glide_track = element.querySelector('.glide__track') || false;
      if (active_slide && glide_track) {
        var active_slide_height = active_slide.offsetHeight;
        var glide_track_height = glide_track.offsetHeight;
        if (glide_track_height != active_slide_height) glide_track.style.height = active_slide_height + 'px';
        AOS.refresh();
      }
    }
  };
  var updateProductGalleryModalTrigger = function updateProductGalleryModalTrigger() {
    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    (document.querySelectorAll('.main-product__image-gallery-modal-trigger') || []).forEach(function (button) {
      button.dataset.productImageGalleryIndex = index;
    });
  };
  var init$2 = function init() {
    elements$2.forEach(function (element) {
      return createGliderFromElement(element);
    });
  };
  var Gliders = {
    gliders: gliders,
    init: init$2
  };

  var addToCartButton = document.querySelector('form[action="/cart/add"] button[type="submit"]') || false;
  var options = document.querySelectorAll('form[action="/cart/add"] input[type="radio"]') || [];
  var elements$1 = {
    modal: document.querySelectorAll('.product-image-gallery-modal') || []
  };
  var isSelected = function isSelected() {
    for (var i = 0; i < options.length; i++) {
      if (options[i].checked) ;
    }
  };
  var showActiveProductImageAfterModalShown = function showActiveProductImageAfterModalShown() {
    elements$1.modal.forEach(function (element) {
      element.addEventListener('shown.bs.modal', function (event) {
        var delay = 250;
        var index = event.relatedTarget.dataset.productImageGalleryIndex || 0;
        var target = document.getElementById("product-image-gallery-modal__item-".concat(index)) || false;
        if (target && target.offsetTop > 50) {
          setTimeout(function () {
            element.scrollTo({
              top: target.offsetTop,
              left: 0,
              behavior: 'smooth'
            });
          }, delay);
        }
      });
    });
  };
  var variantSelector = function variantSelector() {
    options.forEach(function (input) {
      input.addEventListener('input', function (event) {
        if (!input.disabled) {
          addToCartButton.disabled = false;
        }
      });
    });
  };
  var init$1 = function init() {
    isSelected();
    showActiveProductImageAfterModalShown();
    variantSelector();
  };
  var Product = {
    init: init$1
  };

  var _scrollPosition;
  var elements = document.querySelectorAll('body, footer, header, main') || [];
  var classes = {
    atTop: 'scroll-position--at-top',
    scrolled: 'scroll-position--scrolled',
    scrollingDown: 'scroll-position--scrolling-down',
    scrollingUp: 'scroll-position--scrolling-up'
  };
  var scrollPosition = (_scrollPosition = {
    initial: window.pageYOffset || document.documentElement.scrollTop,
    current: window.pageYOffset || document.documentElement.scrollTop
  }, _defineProperty(_scrollPosition, "initial", window.pageYOffset || document.documentElement.scrollTop), _defineProperty(_scrollPosition, "previous", window.pageYOffset || document.documentElement.scrollTop), _defineProperty(_scrollPosition, "down", false), _scrollPosition);
  var currentScrollPosition = function currentScrollPosition() {
    return window.pageYOffset || document.documentElement.scrollTop;
  };
  var setClassesByScrollPosition = function setClassesByScrollPosition() {
    scrollPosition.previous = scrollPosition.current;
    scrollPosition.current = currentScrollPosition();
    scrollPosition.down = scrollPosition.current > scrollPosition.previous ? true : false;

    // set scrolling action state
    if (scrollPosition.current > 30) {
      Tools.addClassesToElements([classes.scrolled], elements);
    } else {
      Tools.removeClassesFromElements([classes.scrolled], elements);
    }

    // set scroll top position state
    if (scrollPosition.current === 0) {
      Tools.addClassesToElements([classes.atTop], elements);
    } else {
      Tools.removeClassesFromElements([classes.atTop], elements);
    }

    // set scroll direction down state
    if (scrollPosition.down) {
      Tools.addClassesToElements([classes.scrollingDown], elements);
      Tools.removeClassesFromElements([classes.scrollingUp], elements);
    } else {
      Tools.addClassesToElements([classes.scrollingUp], elements);
      Tools.removeClassesFromElements([classes.scrollingDown], elements);
    }
  };
  var init = function init() {
    setClassesByScrollPosition();
  };
  var Scrolling = {
    init: init
  };

  Announcements.init();
  Cart.init();
  Credits.init();
  Drawers.init();
  Product.init();
  Scrolling.init();
  AOS.init({
    offset: 150,
    // offset (in px) from the original trigger point
    delay: 0,
    // values from 0 to 3000, with step 50ms
    duration: 500,
    // values from 0 to 3000, with step 50ms
    easing: 'ease-in-out' // default easing for AOS animations
  });

  window.addEventListener('load', function (e) {
    Tools.setElementsHeightToCSSVariable();
    Gliders.init();
    AOS.refresh();
  });
  window.addEventListener('resize', Tools.debounce(function () {
    Tools.setElementsHeightToCSSVariable();
  }, 300));
  window.addEventListener('resize', Tools.throttle(function () {}, 300));
  window.addEventListener('scroll', Tools.debounce(function () {}, 300));
  window.addEventListener('scroll', Tools.throttle(function () {}, 300));

})();
